{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://gemma-notebook/./src/editor/BlockFactory.ts","webpack://gemma-notebook/./src/editor/BlockRenderer.ts","webpack://gemma-notebook/./src/editor/InlineSuggestion.ts","webpack://gemma-notebook/./src/editor/DragAndDrop.ts","webpack://gemma-notebook/./src/editor/Editor.ts","webpack://gemma-notebook/./src/storage/FileStorage.ts","webpack://gemma-notebook/./src/ai/GemmaService.ts","webpack://gemma-notebook/./src/chat/ChatInterface.ts","webpack://gemma-notebook/./src/features/AutoSave.ts","webpack://gemma-notebook/./src/references/ReferenceManager.ts","webpack://gemma-notebook/./src/references/ReferenceUI.ts","webpack://gemma-notebook/./src/index.ts"],"sourcesContent":["export class BlockFactory {\n    createBlock(id, type, content = '', metadata = {}) {\n        const now = new Date();\n        return {\n            id,\n            type,\n            content,\n            metadata: this.getDefaultMetadata(type, metadata),\n            createdAt: now,\n            updatedAt: now\n        };\n    }\n    getDefaultMetadata(type, metadata) {\n        const defaults = {\n            'paragraph': {},\n            'heading-1': { level: 1 },\n            'heading-2': { level: 2 },\n            'heading-3': { level: 3 },\n            'heading-4': { level: 4 },\n            'heading-5': { level: 5 },\n            'heading-6': { level: 6 },\n            'quote': {},\n            'code': { language: 'text' },\n            'bullet-list': { level: 0 },\n            'numbered-list': { level: 0, number: 1 },\n            'checklist': { checked: false, level: 0 },\n            'horizontal-rule': {}\n        };\n        return { ...defaults[type], ...metadata };\n    }\n    static isTextBlock(type) {\n        return [\n            'paragraph',\n            'heading-1',\n            'heading-2',\n            'heading-3',\n            'heading-4',\n            'heading-5',\n            'heading-6',\n            'quote',\n            'code'\n        ].includes(type);\n    }\n    static isListBlock(type) {\n        return ['bullet-list', 'numbered-list', 'checklist'].includes(type);\n    }\n    static isHeadingBlock(type) {\n        return type.startsWith('heading-');\n    }\n    static getHeadingLevel(type) {\n        if (!this.isHeadingBlock(type))\n            return 0;\n        return parseInt(type.split('-')[1]) || 1;\n    }\n}\n","export class BlockRenderer {\n    render(block) {\n        const blockElement = document.createElement('div');\n        blockElement.className = 'block';\n        blockElement.dataset.blockId = block.id;\n        blockElement.dataset.blockType = block.type;\n        blockElement.draggable = false; // We'll handle drag manually\n        // Add drag indicators\n        const topIndicator = document.createElement('div');\n        topIndicator.className = 'drag-indicator top';\n        blockElement.appendChild(topIndicator);\n        const bottomIndicator = document.createElement('div');\n        bottomIndicator.className = 'drag-indicator bottom';\n        blockElement.appendChild(bottomIndicator);\n        // Add block menu\n        const menu = this.createBlockMenu(block);\n        blockElement.appendChild(menu);\n        // Add block type indicator\n        const typeIndicator = document.createElement('div');\n        typeIndicator.className = 'block-type-indicator';\n        typeIndicator.textContent = this.getBlockTypeLabel(block.type);\n        blockElement.appendChild(typeIndicator);\n        // Add drag handle\n        const dragHandle = document.createElement('div');\n        dragHandle.className = 'block-handle';\n        dragHandle.innerHTML = '';\n        dragHandle.title = 'Click and drag to move';\n        blockElement.appendChild(dragHandle);\n        // Create content element based on block type\n        const contentElement = this.createContentElement(block);\n        blockElement.appendChild(contentElement);\n        return blockElement;\n    }\n    createBlockMenu(block) {\n        const menu = document.createElement('div');\n        menu.className = 'block-menu';\n        const addButton = document.createElement('button');\n        addButton.className = 'menu-button add-button';\n        addButton.innerHTML = '+';\n        addButton.title = 'Add block below';\n        menu.appendChild(addButton);\n        return menu;\n    }\n    createContentElement(block) {\n        switch (block.type) {\n            case 'paragraph':\n                return this.createParagraphElement(block);\n            case 'heading-1':\n            case 'heading-2':\n            case 'heading-3':\n            case 'heading-4':\n            case 'heading-5':\n            case 'heading-6':\n                return this.createHeadingElement(block);\n            case 'quote':\n                return this.createQuoteElement(block);\n            case 'code':\n                return this.createCodeElement(block);\n            case 'bullet-list':\n                return this.createBulletListElement(block);\n            case 'numbered-list':\n                return this.createNumberedListElement(block);\n            case 'checklist':\n                return this.createChecklistElement(block);\n            case 'horizontal-rule':\n                return this.createHorizontalRuleElement(block);\n            default:\n                return this.createParagraphElement(block);\n        }\n    }\n    createParagraphElement(block) {\n        const element = document.createElement('div');\n        element.className = 'block-content';\n        element.contentEditable = 'true';\n        element.textContent = block.content;\n        element.setAttribute('data-placeholder', 'Type \\'/\\' for commands, or just start writing...');\n        return element;\n    }\n    createHeadingElement(block) {\n        const level = parseInt(block.type.split('-')[1]) || 1;\n        const element = document.createElement(`h${level}`);\n        element.className = `block-content heading-${level}`;\n        element.contentEditable = 'true';\n        element.textContent = block.content;\n        element.setAttribute('data-placeholder', `Heading ${level}`);\n        return element;\n    }\n    createQuoteElement(block) {\n        const element = document.createElement('blockquote');\n        element.className = 'block-content quote';\n        element.contentEditable = 'true';\n        element.textContent = block.content;\n        element.setAttribute('data-placeholder', 'Empty quote');\n        return element;\n    }\n    createCodeElement(block) {\n        const wrapper = document.createElement('div');\n        wrapper.className = 'code-block';\n        const languageSelect = document.createElement('select');\n        languageSelect.className = 'language-select';\n        languageSelect.style.cssText = 'margin-bottom: 8px; padding: 4px; border: 1px solid #ddd; border-radius: 4px;';\n        const languages = ['text', 'javascript', 'typescript', 'python', 'java', 'html', 'css', 'json', 'markdown'];\n        languages.forEach(lang => {\n            const option = document.createElement('option');\n            option.value = lang;\n            option.textContent = lang;\n            option.selected = lang === (block.metadata?.language || 'text');\n            languageSelect.appendChild(option);\n        });\n        const codeElement = document.createElement('pre');\n        const code = document.createElement('code');\n        code.className = 'block-content';\n        code.contentEditable = 'true';\n        code.textContent = block.content;\n        code.style.cssText = 'outline: none; background: transparent;';\n        code.setAttribute('data-placeholder', 'Enter code...');\n        codeElement.appendChild(code);\n        wrapper.appendChild(languageSelect);\n        wrapper.appendChild(codeElement);\n        // Update language metadata when changed\n        languageSelect.addEventListener('change', () => {\n            block.metadata = { ...block.metadata, language: languageSelect.value };\n        });\n        return wrapper;\n    }\n    createBulletListElement(block) {\n        const wrapper = document.createElement('div');\n        wrapper.className = 'list-item';\n        const marker = document.createElement('span');\n        marker.className = 'list-marker';\n        marker.textContent = '';\n        const content = document.createElement('div');\n        content.className = 'block-content';\n        content.contentEditable = 'true';\n        content.textContent = block.content;\n        wrapper.appendChild(marker);\n        wrapper.appendChild(content);\n        return wrapper;\n    }\n    createNumberedListElement(block) {\n        const wrapper = document.createElement('div');\n        wrapper.className = 'list-item';\n        const marker = document.createElement('span');\n        marker.className = 'list-marker';\n        marker.textContent = `${block.metadata?.number || 1}.`;\n        const content = document.createElement('div');\n        content.className = 'block-content';\n        content.contentEditable = 'true';\n        content.textContent = block.content;\n        wrapper.appendChild(marker);\n        wrapper.appendChild(content);\n        return wrapper;\n    }\n    createChecklistElement(block) {\n        const wrapper = document.createElement('div');\n        wrapper.className = 'list-item checklist-item';\n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.checked = block.metadata?.checked || false;\n        const content = document.createElement('div');\n        content.className = 'block-content';\n        content.contentEditable = 'true';\n        content.textContent = block.content;\n        // Update checked state\n        checkbox.addEventListener('change', () => {\n            block.metadata = { ...block.metadata, checked: checkbox.checked };\n            if (checkbox.checked) {\n                content.style.textDecoration = 'line-through';\n                content.style.color = '#888';\n            }\n            else {\n                content.style.textDecoration = 'none';\n                content.style.color = 'inherit';\n            }\n        });\n        // Apply initial style\n        if (checkbox.checked) {\n            content.style.textDecoration = 'line-through';\n            content.style.color = '#888';\n        }\n        wrapper.appendChild(checkbox);\n        wrapper.appendChild(content);\n        return wrapper;\n    }\n    createHorizontalRuleElement(block) {\n        const hr = document.createElement('hr');\n        hr.className = 'horizontal-rule';\n        return hr;\n    }\n    getBlockTypeLabel(type) {\n        switch (type) {\n            case 'paragraph': return '';\n            case 'heading-1': return 'H1';\n            case 'heading-2': return 'H2';\n            case 'heading-3': return 'H3';\n            case 'heading-4': return 'H4';\n            case 'heading-5': return 'H5';\n            case 'heading-6': return 'H6';\n            case 'quote': return 'QUOTE';\n            case 'code': return 'CODE';\n            case 'bullet-list': return 'LIST';\n            case 'numbered-list': return 'NUM';\n            case 'checklist': return 'TODO';\n            case 'horizontal-rule': return 'HR';\n            default: return '';\n        }\n    }\n    static applyTextFormatting(element, content) {\n        // Apply inline formatting like **bold**, *italic*, ~~strikethrough~~, `code`\n        let formattedContent = content;\n        // Bold formatting\n        formattedContent = formattedContent.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>');\n        // Italic formatting\n        formattedContent = formattedContent.replace(/\\*(.*?)\\*/g, '<em>$1</em>');\n        // Strikethrough formatting\n        formattedContent = formattedContent.replace(/~~(.*?)~~/g, '<del>$1</del>');\n        // Inline code formatting\n        formattedContent = formattedContent.replace(/`(.*?)`/g, '<code style=\"background: #f0f0f0; padding: 2px 4px; border-radius: 3px; font-family: monospace;\">$1</code>');\n        // Link formatting\n        formattedContent = formattedContent.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, '<a href=\"$2\" target=\"_blank\" rel=\"noopener noreferrer\">$1</a>');\n        if (formattedContent !== content) {\n            element.innerHTML = formattedContent;\n        }\n    }\n}\n","export class InlineSuggestion {\n    constructor(gemmaService, referenceManager) {\n        this.currentSuggestion = null;\n        this.suggestionTimeout = null;\n        this.isGenerating = false;\n        this.SUGGESTION_DELAY = 800; // ms to wait after typing stops\n        this.gemmaService = gemmaService;\n        this.referenceManager = referenceManager;\n    }\n    async requestSuggestion(blockId, blockElement, currentText, documentContext) {\n        // Clear any existing suggestion\n        this.clearSuggestion();\n        // Clear existing timeout\n        if (this.suggestionTimeout) {\n            clearTimeout(this.suggestionTimeout);\n        }\n        // Don't generate if already generating or text is too short\n        if (this.isGenerating || currentText.trim().length < 3) {\n            return;\n        }\n        // Set timeout to generate suggestion after user stops typing\n        this.suggestionTimeout = setTimeout(async () => {\n            await this.generateSuggestion(blockId, blockElement, currentText, documentContext);\n        }, this.SUGGESTION_DELAY);\n    }\n    async generateSuggestion(blockId, blockElement, currentText, documentContext) {\n        if (this.isGenerating)\n            return;\n        try {\n            this.isGenerating = true;\n            // Get reference context if available\n            const contextKeywords = this.extractKeywords(currentText + ' ' + documentContext);\n            const referenceContext = this.referenceManager.getRelevantContent(contextKeywords, 1000);\n            // Generate suggestion using AI with reference context\n            const suggestion = await this.gemmaService.generateCompletion(currentText, documentContext, referenceContext);\n            if (suggestion && suggestion.trim() && suggestion !== currentText) {\n                // Clean up the suggestion (remove any duplicate text)\n                const cleanSuggestion = this.cleanSuggestion(currentText, suggestion);\n                if (cleanSuggestion) {\n                    this.showInlineSuggestion(blockId, blockElement, currentText, cleanSuggestion);\n                }\n            }\n        }\n        catch (error) {\n            console.error('Failed to generate inline suggestion:', error);\n        }\n        finally {\n            this.isGenerating = false;\n        }\n    }\n    cleanSuggestion(currentText, rawSuggestion) {\n        let suggestion = rawSuggestion.trim();\n        // Remove any text that duplicates the current text\n        if (suggestion.startsWith(currentText)) {\n            suggestion = suggestion.substring(currentText.length).trim();\n        }\n        // Limit suggestion length to be reasonable\n        const words = suggestion.split(' ');\n        if (words.length > 10) {\n            suggestion = words.slice(0, 10).join(' ') + '...';\n        }\n        // Only show if there's meaningful content\n        return suggestion.length > 2 ? suggestion : '';\n    }\n    showInlineSuggestion(blockId, blockElement, originalText, suggestion) {\n        // Clear any existing suggestion\n        this.clearSuggestion();\n        // Create suggestion element\n        const suggestionElement = this.createSuggestionElement(suggestion);\n        // Find the content element within the block\n        const contentElement = blockElement.querySelector('.block-content');\n        if (!contentElement)\n            return;\n        // Position the suggestion element\n        this.positionSuggestionElement(contentElement, suggestionElement);\n        // Store suggestion state\n        this.currentSuggestion = {\n            blockId,\n            suggestion,\n            originalText,\n            isActive: true,\n            element: suggestionElement\n        };\n        // Show subtle animation\n        suggestionElement.style.opacity = '0';\n        document.body.appendChild(suggestionElement);\n        requestAnimationFrame(() => {\n            suggestionElement.style.transition = 'opacity 0.2s ease';\n            suggestionElement.style.opacity = '0.5';\n        });\n    }\n    createSuggestionElement(suggestion) {\n        const element = document.createElement('span');\n        element.className = 'inline-suggestion';\n        element.textContent = suggestion;\n        element.style.cssText = `\n      position: absolute;\n      color: #999;\n      font-family: inherit;\n      font-size: inherit;\n      line-height: inherit;\n      pointer-events: none;\n      white-space: pre-wrap;\n      z-index: 100;\n      opacity: 0.5;\n      font-style: italic;\n    `;\n        return element;\n    }\n    positionSuggestionElement(contentElement, suggestionElement) {\n        const selection = window.getSelection();\n        if (!selection || selection.rangeCount === 0)\n            return;\n        const range = selection.getRangeAt(0);\n        const rect = range.getBoundingClientRect();\n        const contentRect = contentElement.getBoundingClientRect();\n        // Position suggestion right after the cursor\n        suggestionElement.style.left = `${rect.left}px`;\n        suggestionElement.style.top = `${rect.top}px`;\n    }\n    acceptSuggestion() {\n        if (!this.currentSuggestion || !this.currentSuggestion.isActive) {\n            return false;\n        }\n        const { blockId, suggestion, originalText } = this.currentSuggestion;\n        const newText = originalText + suggestion.replace(/\\.\\.\\.$/, ''); // Remove trailing dots if present\n        // Clear the suggestion\n        this.clearSuggestion();\n        // Dispatch event to update the block content\n        const event = new CustomEvent('acceptSuggestion', {\n            detail: { blockId, newText }\n        });\n        window.dispatchEvent(event);\n        return true;\n    }\n    clearSuggestion() {\n        if (this.currentSuggestion?.element) {\n            this.currentSuggestion.element.remove();\n        }\n        this.currentSuggestion = null;\n        if (this.suggestionTimeout) {\n            clearTimeout(this.suggestionTimeout);\n            this.suggestionTimeout = null;\n        }\n    }\n    hasSuggestion() {\n        return this.currentSuggestion?.isActive ?? false;\n    }\n    getCurrentSuggestion() {\n        return this.currentSuggestion;\n    }\n    // Update suggestion position when text changes\n    updateSuggestionPosition(blockElement) {\n        if (!this.currentSuggestion || !this.currentSuggestion.element)\n            return;\n        const contentElement = blockElement.querySelector('.block-content');\n        if (contentElement) {\n            this.positionSuggestionElement(contentElement, this.currentSuggestion.element);\n        }\n    }\n    // Check if suggestion is still valid (text hasn't changed too much)\n    isSuggestionValid(currentText) {\n        if (!this.currentSuggestion)\n            return false;\n        // If the original text is still a prefix of current text, suggestion might still be valid\n        return currentText.startsWith(this.currentSuggestion.originalText);\n    }\n    destroy() {\n        this.clearSuggestion();\n        if (this.suggestionTimeout) {\n            clearTimeout(this.suggestionTimeout);\n        }\n    }\n    extractKeywords(text) {\n        // Simple keyword extraction - split by words and filter meaningful ones\n        const words = text\n            .toLowerCase()\n            .replace(/[^\\w\\s]/g, ' ')\n            .split(/\\s+/)\n            .filter(word => word.length > 3) // Filter short words\n            .filter(word => !this.isStopWord(word));\n        // Return unique words, limited to avoid too much context\n        return [...new Set(words)].slice(0, 10);\n    }\n    isStopWord(word) {\n        const stopWords = new Set([\n            'this', 'that', 'with', 'have', 'will', 'from', 'they', 'been',\n            'were', 'said', 'each', 'which', 'their', 'time', 'about', 'there',\n            'could', 'other', 'more', 'very', 'what', 'know', 'just', 'first',\n            'into', 'over', 'think', 'also', 'your', 'work', 'life', 'only',\n            'new', 'would', 'come', 'its', 'after', 'way', 'who', 'may',\n            'say', 'great', 'where', 'much', 'should', 'well', 'large', 'use'\n        ]);\n        return stopWords.has(word);\n    }\n}\n","export class DragAndDrop {\n    constructor(editor, editorElement) {\n        this.draggedElement = null;\n        this.draggedBlockId = null;\n        this.isDragging = false;\n        this.startY = 0;\n        this.startX = 0;\n        this.editor = editor;\n        this.editorElement = editorElement;\n        this.setupEventListeners();\n    }\n    setupEventListeners() {\n        // Use event delegation for better performance\n        this.editorElement.addEventListener('mousedown', this.handleMouseDown.bind(this));\n        document.addEventListener('mousemove', this.handleMouseMove.bind(this));\n        document.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    }\n    handleMouseDown(event) {\n        const target = event.target;\n        // Check if clicked on drag handle\n        if (!target.closest('.block-handle')) {\n            return;\n        }\n        const blockElement = target.closest('.block');\n        if (!blockElement) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        this.draggedElement = blockElement;\n        this.draggedBlockId = blockElement.dataset.blockId || null;\n        this.startY = event.clientY;\n        this.startX = event.clientX;\n        // Add dragging class after a small delay to ensure it's a drag, not just a click\n        setTimeout(() => {\n            if (this.draggedElement && this.isDragging) {\n                this.draggedElement.classList.add('dragging');\n            }\n        }, 100);\n    }\n    handleMouseMove(event) {\n        if (!this.draggedElement || !this.draggedBlockId) {\n            return;\n        }\n        const deltaY = Math.abs(event.clientY - this.startY);\n        const deltaX = Math.abs(event.clientX - this.startX);\n        // Start dragging if moved enough\n        if (!this.isDragging && (deltaY > 5 || deltaX > 5)) {\n            this.isDragging = true;\n            this.draggedElement.classList.add('dragging');\n            document.body.style.cursor = 'grabbing';\n            document.body.style.userSelect = 'none';\n        }\n        if (!this.isDragging) {\n            return;\n        }\n        // Find the block we're hovering over\n        const hoveredElement = this.getBlockElementUnderCursor(event.clientX, event.clientY);\n        // Clear all drag-over classes\n        this.clearDragOverClasses();\n        if (hoveredElement && hoveredElement !== this.draggedElement) {\n            const rect = hoveredElement.getBoundingClientRect();\n            const midPoint = rect.top + (rect.height / 2);\n            if (event.clientY < midPoint) {\n                hoveredElement.classList.add('drag-over-top');\n            }\n            else {\n                hoveredElement.classList.add('drag-over-bottom');\n            }\n        }\n    }\n    handleMouseUp(event) {\n        if (!this.isDragging || !this.draggedElement || !this.draggedBlockId) {\n            this.cleanup();\n            return;\n        }\n        // Find the target position\n        const targetElement = this.getBlockElementUnderCursor(event.clientX, event.clientY);\n        if (targetElement && targetElement !== this.draggedElement) {\n            const targetBlockId = targetElement.dataset.blockId;\n            if (targetBlockId) {\n                const rect = targetElement.getBoundingClientRect();\n                const midPoint = rect.top + (rect.height / 2);\n                const insertAbove = event.clientY < midPoint;\n                this.moveBlock(this.draggedBlockId, targetBlockId, insertAbove);\n            }\n        }\n        this.cleanup();\n    }\n    getBlockElementUnderCursor(x, y) {\n        // Temporarily hide the dragged element to get the element underneath\n        const originalDisplay = this.draggedElement?.style.display;\n        if (this.draggedElement) {\n            this.draggedElement.style.display = 'none';\n        }\n        const elementUnder = document.elementFromPoint(x, y);\n        const blockElement = elementUnder?.closest('.block');\n        // Restore the dragged element\n        if (this.draggedElement && originalDisplay !== undefined) {\n            this.draggedElement.style.display = originalDisplay;\n        }\n        return blockElement;\n    }\n    clearDragOverClasses() {\n        const blocks = this.editorElement.querySelectorAll('.block');\n        blocks.forEach(block => {\n            block.classList.remove('drag-over-top', 'drag-over-bottom');\n        });\n    }\n    moveBlock(draggedBlockId, targetBlockId, insertAbove) {\n        // Get the current indices\n        const blocks = this.editor.getBlocks();\n        const draggedIndex = blocks.findIndex(b => b.id === draggedBlockId);\n        const targetIndex = blocks.findIndex(b => b.id === targetBlockId);\n        if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) {\n            return;\n        }\n        // Calculate new position\n        let newIndex = targetIndex;\n        if (!insertAbove) {\n            newIndex = targetIndex + 1;\n        }\n        // Adjust for removal of dragged element\n        if (draggedIndex < newIndex) {\n            newIndex--;\n        }\n        // Use the editor's move method\n        this.editor.moveBlock(draggedBlockId, newIndex);\n    }\n    cleanup() {\n        if (this.draggedElement) {\n            this.draggedElement.classList.remove('dragging');\n        }\n        this.clearDragOverClasses();\n        document.body.style.cursor = '';\n        document.body.style.userSelect = '';\n        this.draggedElement = null;\n        this.draggedBlockId = null;\n        this.isDragging = false;\n    }\n    destroy() {\n        // Remove event listeners if needed\n        // In a real implementation, we'd store references to bound functions\n        this.cleanup();\n    }\n}\n","import { BlockFactory } from './BlockFactory';\nimport { BlockRenderer } from './BlockRenderer';\nimport { InlineSuggestion } from './InlineSuggestion';\nimport { DragAndDrop } from './DragAndDrop';\nexport class Editor {\n    constructor(container, gemmaService, referenceManager) {\n        this.blocks = [];\n        this.currentBlockId = null;\n        this.blockIdCounter = 0;\n        this.container = container;\n        this.gemmaService = gemmaService;\n        this.referenceManager = referenceManager;\n        this.blockFactory = new BlockFactory();\n        this.blockRenderer = new BlockRenderer();\n        this.inlineSuggestion = new InlineSuggestion(gemmaService, referenceManager);\n        this.initializeEditor();\n        this.setupEventListeners();\n        this.setupSuggestionHandlers();\n        // Initialize drag and drop after editor element is ready\n        this.dragAndDrop = new DragAndDrop(this, this.editorElement);\n        // Start with an empty paragraph\n        this.addBlock('paragraph');\n    }\n    initializeEditor() {\n        this.editorElement = this.container.querySelector('#editor');\n        if (!this.editorElement) {\n            this.editorElement = document.createElement('div');\n            this.editorElement.className = 'editor';\n            this.editorElement.id = 'editor';\n            this.container.appendChild(this.editorElement);\n        }\n    }\n    setupEventListeners() {\n        this.editorElement.addEventListener('keydown', this.handleKeyDown.bind(this));\n        this.editorElement.addEventListener('input', this.handleInput.bind(this));\n        this.editorElement.addEventListener('click', this.handleClick.bind(this));\n    }\n    setupSuggestionHandlers() {\n        // Listen for suggestion acceptance\n        window.addEventListener('acceptSuggestion', (event) => {\n            const customEvent = event;\n            const { blockId, newText } = customEvent.detail;\n            this.updateBlock(blockId, { content: newText });\n            // Focus the block and position cursor at the end\n            setTimeout(() => {\n                this.focusBlock(blockId, 'end');\n            }, 10);\n        });\n    }\n    handleKeyDown(event) {\n        const target = event.target;\n        const blockElement = target.closest('.block');\n        if (!blockElement)\n            return;\n        const blockId = blockElement.dataset.blockId;\n        if (!blockId)\n            return;\n        switch (event.key) {\n            case 'Enter':\n                event.preventDefault();\n                this.handleEnterKey(blockId, event.shiftKey);\n                break;\n            case 'Backspace':\n                this.handleBackspaceKey(blockId, target);\n                break;\n            case 'ArrowUp':\n                this.handleArrowKey(blockId, 'up');\n                break;\n            case 'ArrowDown':\n                this.handleArrowKey(blockId, 'down');\n                break;\n            case 'Tab':\n                event.preventDefault();\n                // Check if there's an active suggestion to accept\n                if (this.inlineSuggestion.hasSuggestion()) {\n                    this.inlineSuggestion.acceptSuggestion();\n                }\n                else {\n                    this.handleTab(blockId, event.shiftKey);\n                }\n                break;\n            case '/':\n                // Trigger AI command palette\n                if (event.ctrlKey || event.metaKey) {\n                    event.preventDefault();\n                    this.showAICommandPalette(blockId);\n                }\n                break;\n            case 'Escape':\n                // Clear any active suggestion\n                if (this.inlineSuggestion.hasSuggestion()) {\n                    event.preventDefault();\n                    this.inlineSuggestion.clearSuggestion();\n                }\n                break;\n        }\n    }\n    handleInput(event) {\n        const inputEvent = event;\n        const target = event.target;\n        const blockElement = target.closest('.block');\n        if (!blockElement)\n            return;\n        const blockId = blockElement.dataset.blockId;\n        if (!blockId)\n            return;\n        const block = this.getBlockById(blockId);\n        if (!block)\n            return;\n        // Update block content\n        const newContent = target.textContent || '';\n        block.content = newContent;\n        // Clear suggestion if text changed significantly\n        if (this.inlineSuggestion.hasSuggestion() && !this.inlineSuggestion.isSuggestionValid(newContent)) {\n            this.inlineSuggestion.clearSuggestion();\n        }\n        // Handle markdown-like shortcuts\n        this.handleMarkdownShortcuts(block, target);\n        // Trigger inline suggestion for certain input types (but not spaces to avoid interruption)\n        if (inputEvent.inputType === 'insertText' && inputEvent.data !== ' ' && newContent.length > 2) {\n            const context = this.getDocumentContext();\n            this.inlineSuggestion.requestSuggestion(blockId, blockElement, newContent, context);\n        }\n        // Update suggestion position if it exists\n        if (this.inlineSuggestion.hasSuggestion()) {\n            this.inlineSuggestion.updateSuggestionPosition(blockElement);\n        }\n        this.notifyChange();\n    }\n    handleClick(event) {\n        const target = event.target;\n        const blockElement = target.closest('.block');\n        // Clear suggestions when clicking (user is repositioning cursor)\n        this.inlineSuggestion.clearSuggestion();\n        if (blockElement) {\n            const blockId = blockElement.dataset.blockId;\n            if (blockId) {\n                this.setCurrentBlock(blockId);\n            }\n        }\n    }\n    handleEnterKey(blockId, shiftKey) {\n        if (shiftKey) {\n            // Shift+Enter: insert line break\n            document.execCommand('insertLineBreak');\n            return;\n        }\n        const block = this.getBlockById(blockId);\n        if (!block)\n            return;\n        const selection = window.getSelection();\n        if (!selection)\n            return;\n        const range = selection.getRangeAt(0);\n        const beforeCursor = range.startContainer.textContent?.substring(0, range.startOffset) || '';\n        const afterCursor = range.startContainer.textContent?.substring(range.startOffset) || '';\n        // Update current block with content before cursor\n        block.content = beforeCursor;\n        this.updateBlockElement(block);\n        // Find the index of the current block to insert after it\n        const currentBlockIndex = this.blocks.findIndex(b => b.id === blockId);\n        if (currentBlockIndex === -1)\n            return;\n        // Create new block with content after cursor, inserted right after current block\n        const newBlockId = this.addBlock('paragraph', afterCursor, currentBlockIndex + 1);\n        // Focus new block\n        setTimeout(() => {\n            this.focusBlock(newBlockId);\n        }, 0);\n    }\n    handleBackspaceKey(blockId, target) {\n        const block = this.getBlockById(blockId);\n        if (!block)\n            return;\n        const selection = window.getSelection();\n        if (!selection || selection.rangeCount === 0)\n            return;\n        const range = selection.getRangeAt(0);\n        // If cursor is at the beginning of the block and block is empty\n        if (range.startOffset === 0 && (!block.content || block.content.trim() === '')) {\n            const blockIndex = this.blocks.findIndex(b => b.id === blockId);\n            if (blockIndex > 0) {\n                // Remove current block and focus previous one\n                this.removeBlock(blockId);\n                const prevBlock = this.blocks[blockIndex - 1];\n                if (prevBlock) {\n                    this.focusBlock(prevBlock.id, 'end');\n                }\n            }\n        }\n    }\n    handleArrowKey(blockId, direction) {\n        // Clear suggestions when navigating with arrows\n        this.inlineSuggestion.clearSuggestion();\n        const blockIndex = this.blocks.findIndex(b => b.id === blockId);\n        if (direction === 'up' && blockIndex > 0) {\n            this.focusBlock(this.blocks[blockIndex - 1].id, 'end');\n        }\n        else if (direction === 'down' && blockIndex < this.blocks.length - 1) {\n            this.focusBlock(this.blocks[blockIndex + 1].id, 'start');\n        }\n    }\n    handleTab(blockId, shiftKey) {\n        // Handle indentation for lists\n        const block = this.getBlockById(blockId);\n        if (!block)\n            return;\n        if (block.type.includes('list')) {\n            // Implement list indentation logic\n            console.log('List indentation not yet implemented');\n        }\n    }\n    handleMarkdownShortcuts(block, target) {\n        const content = target.textContent || '';\n        // Check for heading shortcuts\n        const headingMatch = content.match(/^(#{1,6})\\s(.*)$/);\n        if (headingMatch) {\n            const level = headingMatch[1].length;\n            const text = headingMatch[2];\n            block.type = `heading-${level}`;\n            block.content = text;\n            this.updateBlockElement(block);\n            this.focusBlock(block.id, 'end');\n            return;\n        }\n        // Check for quote shortcut\n        if (content.startsWith('> ')) {\n            block.type = 'quote';\n            block.content = content.substring(2);\n            this.updateBlockElement(block);\n            this.focusBlock(block.id, 'end');\n            return;\n        }\n        // Check for code block shortcut\n        if (content.startsWith('``` ')) {\n            block.type = 'code';\n            block.content = content.substring(4);\n            this.updateBlockElement(block);\n            this.focusBlock(block.id, 'end');\n            return;\n        }\n        // Check for horizontal rule\n        if (content === '---' || content === '***') {\n            block.type = 'horizontal-rule';\n            block.content = '';\n            this.updateBlockElement(block);\n            // Add new paragraph after horizontal rule\n            const newBlockId = this.addBlock('paragraph');\n            this.focusBlock(newBlockId);\n            return;\n        }\n        // Check for bullet list\n        if (content.startsWith('- ') || content.startsWith('* ')) {\n            block.type = 'bullet-list';\n            block.content = content.substring(2);\n            this.updateBlockElement(block);\n            this.focusBlock(block.id, 'end');\n            return;\n        }\n        // Check for numbered list\n        const numberedMatch = content.match(/^(\\d+)\\.\\s(.*)$/);\n        if (numberedMatch) {\n            block.type = 'numbered-list';\n            block.content = numberedMatch[2];\n            this.updateBlockElement(block);\n            this.focusBlock(block.id, 'end');\n            return;\n        }\n        // Check for checklist\n        if (content.startsWith('- [ ] ') || content.startsWith('- [x] ')) {\n            block.type = 'checklist';\n            block.content = content.substring(6);\n            block.metadata = { checked: content.includes('[x]') };\n            this.updateBlockElement(block);\n            this.focusBlock(block.id, 'end');\n            return;\n        }\n    }\n    addBlock(type, content = '', index) {\n        const blockId = `block-${++this.blockIdCounter}`;\n        const block = this.blockFactory.createBlock(blockId, type, content);\n        if (index !== undefined) {\n            this.blocks.splice(index, 0, block);\n        }\n        else {\n            this.blocks.push(block);\n        }\n        this.renderBlock(block, index);\n        this.notifyChange();\n        return blockId;\n    }\n    removeBlock(blockId) {\n        const index = this.blocks.findIndex(b => b.id === blockId);\n        if (index !== -1) {\n            this.blocks.splice(index, 1);\n            const blockElement = this.editorElement.querySelector(`[data-block-id=\"${blockId}\"]`);\n            if (blockElement) {\n                blockElement.remove();\n            }\n            this.notifyChange();\n        }\n    }\n    updateBlock(blockId, updates) {\n        const block = this.getBlockById(blockId);\n        if (block) {\n            Object.assign(block, updates);\n            this.updateBlockElement(block);\n            this.notifyChange();\n        }\n    }\n    moveBlock(blockId, newIndex) {\n        const currentIndex = this.blocks.findIndex(b => b.id === blockId);\n        if (currentIndex !== -1 && newIndex >= 0 && newIndex < this.blocks.length) {\n            const [block] = this.blocks.splice(currentIndex, 1);\n            this.blocks.splice(newIndex, 0, block);\n            this.rerenderEditor();\n            this.notifyChange();\n        }\n    }\n    renderBlock(block, index) {\n        const blockElement = this.blockRenderer.render(block);\n        if (index !== undefined && index < this.editorElement.children.length) {\n            this.editorElement.insertBefore(blockElement, this.editorElement.children[index]);\n        }\n        else {\n            this.editorElement.appendChild(blockElement);\n        }\n    }\n    updateBlockElement(block) {\n        const blockElement = this.editorElement.querySelector(`[data-block-id=\"${block.id}\"]`);\n        if (blockElement) {\n            const newElement = this.blockRenderer.render(block);\n            blockElement.replaceWith(newElement);\n        }\n    }\n    rerenderEditor() {\n        this.editorElement.innerHTML = '';\n        this.blocks.forEach(block => this.renderBlock(block));\n    }\n    getBlockById(blockId) {\n        return this.blocks.find(b => b.id === blockId);\n    }\n    setCurrentBlock(blockId) {\n        this.currentBlockId = blockId;\n    }\n    focusBlock(blockId, position = 'start') {\n        const blockElement = this.editorElement.querySelector(`[data-block-id=\"${blockId}\"] .block-content`);\n        if (blockElement) {\n            blockElement.focus();\n            const selection = window.getSelection();\n            const range = document.createRange();\n            if (position === 'end') {\n                range.selectNodeContents(blockElement);\n                range.collapse(false);\n            }\n            else {\n                range.setStart(blockElement, 0);\n                range.collapse(true);\n            }\n            selection?.removeAllRanges();\n            selection?.addRange(range);\n        }\n    }\n    getDocumentContext() {\n        return this.blocks.map(block => block.content).join('\\n');\n    }\n    getReferenceContext(instruction) {\n        // Extract keywords from instruction and document context\n        const documentText = this.getDocumentContext();\n        const allText = instruction + ' ' + documentText;\n        const keywords = this.extractKeywords(allText);\n        // Get relevant reference content\n        return this.referenceManager.getRelevantContent(keywords, 2000);\n    }\n    extractKeywords(text) {\n        // Simple keyword extraction - split by words and filter meaningful ones\n        const words = text\n            .toLowerCase()\n            .replace(/[^\\w\\s]/g, ' ')\n            .split(/\\s+/)\n            .filter(word => word.length > 3) // Filter short words\n            .filter(word => !this.isStopWord(word));\n        // Return unique words, limited to avoid too much context\n        return [...new Set(words)].slice(0, 15);\n    }\n    isStopWord(word) {\n        const stopWords = new Set([\n            'this', 'that', 'with', 'have', 'will', 'from', 'they', 'been',\n            'were', 'said', 'each', 'which', 'their', 'time', 'about', 'there',\n            'could', 'other', 'more', 'very', 'what', 'know', 'just', 'first',\n            'into', 'over', 'think', 'also', 'your', 'work', 'life', 'only',\n            'new', 'would', 'come', 'its', 'after', 'way', 'who', 'may',\n            'say', 'great', 'where', 'much', 'should', 'well', 'large', 'use',\n            'make', 'write', 'generate', 'create', 'please', 'help'\n        ]);\n        return stopWords.has(word);\n    }\n    notifyChange() {\n        // Notify other components about editor changes\n        const event = new CustomEvent('editorChange', {\n            detail: { blocks: this.blocks }\n        });\n        window.dispatchEvent(event);\n    }\n    getState() {\n        return {\n            blocks: [...this.blocks],\n            currentBlockId: this.currentBlockId\n        };\n    }\n    loadContent(state) {\n        this.blocks = [...state.blocks];\n        this.currentBlockId = state.currentBlockId;\n        this.blockIdCounter = Math.max(...this.blocks.map(b => parseInt(b.id.split('-')[1]) || 0));\n        this.rerenderEditor();\n    }\n    getBlocks() {\n        return [...this.blocks];\n    }\n    showAutoCompletionNotification(message) {\n        const notification = document.createElement('div');\n        notification.textContent = message;\n        notification.style.cssText = `\n      position: fixed;\n      top: 70px;\n      right: 20px;\n      background: #4caf50;\n      color: white;\n      padding: 8px 16px;\n      border-radius: 4px;\n      font-size: 14px;\n      z-index: 1000;\n      animation: slideInRight 0.3s ease;\n      box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n    `;\n        document.body.appendChild(notification);\n        setTimeout(() => {\n            notification.style.animation = 'slideOutRight 0.3s ease';\n            setTimeout(() => {\n                if (notification.parentNode) {\n                    notification.remove();\n                }\n            }, 300);\n        }, 2000);\n    }\n    async insertAIGeneratedContent(instruction, insertAtCurrentBlock = true) {\n        try {\n            const context = this.getDocumentContext();\n            const referenceContext = this.getReferenceContext(instruction);\n            let insertIndex = this.blocks.length;\n            if (insertAtCurrentBlock && this.currentBlockId) {\n                const currentIndex = this.blocks.findIndex(b => b.id === this.currentBlockId);\n                insertIndex = currentIndex + 1;\n            }\n            // Show loading indicator\n            const loadingBlockId = this.addBlock('paragraph', ' Generating content...', insertIndex);\n            // Generate content with reference context\n            const generatedContent = await this.gemmaService.composeDocument(instruction, context, referenceContext);\n            if (generatedContent && generatedContent.trim()) {\n                // Remove loading block\n                this.removeBlock(loadingBlockId);\n                // Parse and insert the generated content as blocks\n                this.insertGeneratedContentAsBlocks(generatedContent, insertIndex);\n                this.showAutoCompletionNotification('AI content generated and inserted!');\n            }\n            else {\n                // Remove loading block if no content generated\n                this.removeBlock(loadingBlockId);\n                this.showAutoCompletionNotification('No content generated');\n            }\n        }\n        catch (error) {\n            console.error('AI content generation failed:', error);\n            this.showAutoCompletionNotification('AI generation failed');\n        }\n    }\n    insertGeneratedContentAsBlocks(content, startIndex) {\n        const lines = content.split('\\n').filter(line => line.trim());\n        let currentIndex = startIndex;\n        for (const line of lines) {\n            const trimmedLine = line.trim();\n            if (!trimmedLine)\n                continue;\n            // Determine block type based on content\n            let blockType = 'paragraph';\n            let blockContent = trimmedLine;\n            let metadata = {};\n            // Check for headings\n            const headingMatch = trimmedLine.match(/^(#{1,6})\\s(.+)$/);\n            if (headingMatch) {\n                const level = headingMatch[1].length;\n                blockType = `heading-${level}`;\n                blockContent = headingMatch[2];\n                metadata = { level };\n            }\n            // Check for bullet lists\n            else if (trimmedLine.startsWith('- ')) {\n                blockType = 'bullet-list';\n                blockContent = trimmedLine.substring(2);\n                metadata = { level: 0 };\n            }\n            // Check for numbered lists\n            else if (trimmedLine.match(/^\\d+\\.\\s/)) {\n                blockType = 'numbered-list';\n                const match = trimmedLine.match(/^(\\d+)\\.\\s(.+)$/);\n                if (match) {\n                    blockContent = match[2];\n                    metadata = { level: 0, number: parseInt(match[1]) };\n                }\n            }\n            // Check for quotes\n            else if (trimmedLine.startsWith('> ')) {\n                blockType = 'quote';\n                blockContent = trimmedLine.substring(2);\n            }\n            // Check for code blocks\n            else if (trimmedLine.startsWith('```')) {\n                blockType = 'code';\n                blockContent = trimmedLine.substring(3).trim();\n                metadata = { language: blockContent || 'text' };\n                blockContent = ''; // Code content would be on next lines\n            }\n            this.addBlock(blockType, blockContent, currentIndex);\n            currentIndex++;\n        }\n    }\n    async streamAIContentIntoEditor(instruction) {\n        try {\n            const context = this.getDocumentContext();\n            const referenceContext = this.getReferenceContext(instruction);\n            let insertIndex = this.blocks.length;\n            if (this.currentBlockId) {\n                const currentIndex = this.blocks.findIndex(b => b.id === this.currentBlockId);\n                insertIndex = currentIndex + 1;\n            }\n            // Create a block for streaming content\n            const streamingBlockId = this.addBlock('paragraph', '', insertIndex);\n            let accumulatedContent = '';\n            await this.gemmaService.streamComposeDocument(instruction, (chunk) => {\n                accumulatedContent += chunk;\n                this.updateBlock(streamingBlockId, { content: accumulatedContent });\n                // Auto-scroll to the streaming block\n                const blockElement = this.editorElement.querySelector(`[data-block-id=\"${streamingBlockId}\"]`);\n                if (blockElement && typeof blockElement.scrollIntoView === 'function') {\n                    blockElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\n                }\n            }, context, referenceContext);\n            // After streaming is complete, parse content into proper blocks\n            if (accumulatedContent.trim()) {\n                this.removeBlock(streamingBlockId);\n                this.insertGeneratedContentAsBlocks(accumulatedContent, insertIndex);\n                this.showAutoCompletionNotification('AI content streamed successfully!');\n            }\n        }\n        catch (error) {\n            console.error('Streaming AI content failed:', error);\n            this.showAutoCompletionNotification('Streaming failed');\n        }\n    }\n    showAICommandPalette(blockId) {\n        const palette = document.createElement('div');\n        palette.className = 'ai-command-palette';\n        palette.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      background: white;\n      border: 1px solid #ddd;\n      border-radius: 8px;\n      box-shadow: 0 4px 20px rgba(0,0,0,0.15);\n      padding: 20px;\n      width: 400px;\n      z-index: 1001;\n    `;\n        const title = document.createElement('h3');\n        title.textContent = ' AI Assistant';\n        title.style.cssText = 'margin: 0 0 15px 0; color: #333;';\n        const input = document.createElement('input');\n        input.type = 'text';\n        input.placeholder = 'What would you like me to write? (e.g., \"Write a paragraph about...\")';\n        input.style.cssText = `\n      width: 100%;\n      padding: 12px;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      font-size: 14px;\n      outline: none;\n      margin-bottom: 15px;\n    `;\n        const buttonsContainer = document.createElement('div');\n        buttonsContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';\n        const generateButton = document.createElement('button');\n        generateButton.textContent = 'Generate';\n        generateButton.style.cssText = `\n      background: #2196f3;\n      color: white;\n      border: none;\n      padding: 8px 16px;\n      border-radius: 4px;\n      cursor: pointer;\n      font-size: 14px;\n    `;\n        const cancelButton = document.createElement('button');\n        cancelButton.textContent = 'Cancel';\n        cancelButton.style.cssText = `\n      background: #666;\n      color: white;\n      border: none;\n      padding: 8px 16px;\n      border-radius: 4px;\n      cursor: pointer;\n      font-size: 14px;\n    `;\n        // Event handlers\n        const handleGenerate = async () => {\n            const instruction = input.value.trim();\n            if (!instruction)\n                return;\n            document.body.removeChild(palette);\n            await this.streamAIContentIntoEditor(instruction);\n        };\n        const handleCancel = () => {\n            document.body.removeChild(palette);\n            this.focusBlock(blockId);\n        };\n        generateButton.addEventListener('click', handleGenerate);\n        cancelButton.addEventListener('click', handleCancel);\n        input.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') {\n                e.preventDefault();\n                handleGenerate();\n            }\n            else if (e.key === 'Escape') {\n                e.preventDefault();\n                handleCancel();\n            }\n        });\n        buttonsContainer.appendChild(cancelButton);\n        buttonsContainer.appendChild(generateButton);\n        palette.appendChild(title);\n        palette.appendChild(input);\n        palette.appendChild(buttonsContainer);\n        document.body.appendChild(palette);\n        input.focus();\n    }\n    destroy() {\n        // Clean up inline suggestions\n        this.inlineSuggestion.destroy();\n        // Clean up drag and drop\n        this.dragAndDrop.destroy();\n        // Note: In a real implementation, we'd store the handler reference to properly remove it\n        // For now, this is just a placeholder for cleanup\n    }\n}\n","export class FileStorage {\n    constructor() {\n        this.storageKey = 'gemma-notebook';\n        this.metadataKey = 'gemma-notebook-metadata';\n    }\n    async save(filename, content) {\n        try {\n            const serializedContent = JSON.stringify(content);\n            const storageData = this.getStorageData();\n            storageData[filename] = serializedContent;\n            localStorage.setItem(this.storageKey, JSON.stringify(storageData));\n            // Update metadata\n            this.updateMetadata(filename, serializedContent.length);\n            console.log(`Document saved: ${filename}`);\n        }\n        catch (error) {\n            console.error('Failed to save document:', error);\n            throw new Error(`Failed to save document: ${filename}`);\n        }\n    }\n    async load(filename) {\n        try {\n            const storageData = this.getStorageData();\n            const serializedContent = storageData[filename];\n            if (!serializedContent) {\n                return null;\n            }\n            const content = JSON.parse(serializedContent);\n            // Convert date strings back to Date objects\n            content.blocks = content.blocks.map(block => ({\n                ...block,\n                createdAt: new Date(block.createdAt),\n                updatedAt: new Date(block.updatedAt)\n            }));\n            console.log(`Document loaded: ${filename}`);\n            return content;\n        }\n        catch (error) {\n            console.error(`Failed to load document: ${filename}`, error);\n            throw new Error(`Failed to load document: ${filename}`);\n        }\n    }\n    async delete(filename) {\n        try {\n            const storageData = this.getStorageData();\n            delete storageData[filename];\n            localStorage.setItem(this.storageKey, JSON.stringify(storageData));\n            // Remove from metadata\n            this.removeMetadata(filename);\n            console.log(`Document deleted: ${filename}`);\n        }\n        catch (error) {\n            console.error(`Failed to delete document: ${filename}`, error);\n            throw new Error(`Failed to delete document: ${filename}`);\n        }\n    }\n    async exists(filename) {\n        const storageData = this.getStorageData();\n        return filename in storageData;\n    }\n    async list() {\n        try {\n            const metadata = this.getMetadata();\n            return Object.values(metadata).sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());\n        }\n        catch (error) {\n            console.error('Failed to list documents:', error);\n            return [];\n        }\n    }\n    async export(filename, format = 'json') {\n        const content = await this.load(filename);\n        if (!content) {\n            throw new Error(`Document not found: ${filename}`);\n        }\n        switch (format) {\n            case 'json':\n                return JSON.stringify(content, null, 2);\n            case 'markdown':\n                return this.convertToMarkdown(content);\n            case 'text':\n                return this.convertToText(content);\n            default:\n                throw new Error(`Unsupported export format: ${format}`);\n        }\n    }\n    async import(filename, data, format = 'json') {\n        let content;\n        switch (format) {\n            case 'json':\n                content = JSON.parse(data);\n                break;\n            case 'markdown':\n                content = this.convertFromMarkdown(data);\n                break;\n            case 'text':\n                content = this.convertFromText(data);\n                break;\n            default:\n                throw new Error(`Unsupported import format: ${format}`);\n        }\n        await this.save(filename, content);\n    }\n    getStorageData() {\n        try {\n            const data = localStorage.getItem(this.storageKey);\n            return data ? JSON.parse(data) : {};\n        }\n        catch (error) {\n            console.error('Failed to parse storage data:', error);\n            return {};\n        }\n    }\n    getMetadata() {\n        try {\n            const data = localStorage.getItem(this.metadataKey);\n            const metadata = data ? JSON.parse(data) : {};\n            // Convert date strings back to Date objects\n            Object.values(metadata).forEach((file) => {\n                file.createdAt = new Date(file.createdAt);\n                file.updatedAt = new Date(file.updatedAt);\n            });\n            return metadata;\n        }\n        catch (error) {\n            console.error('Failed to parse metadata:', error);\n            return {};\n        }\n    }\n    updateMetadata(filename, size) {\n        const metadata = this.getMetadata();\n        const now = new Date();\n        if (metadata[filename]) {\n            metadata[filename].updatedAt = now;\n            metadata[filename].size = size;\n        }\n        else {\n            metadata[filename] = {\n                name: filename,\n                path: filename,\n                createdAt: now,\n                updatedAt: now,\n                size\n            };\n        }\n        localStorage.setItem(this.metadataKey, JSON.stringify(metadata));\n    }\n    removeMetadata(filename) {\n        const metadata = this.getMetadata();\n        delete metadata[filename];\n        localStorage.setItem(this.metadataKey, JSON.stringify(metadata));\n    }\n    convertToMarkdown(content) {\n        return content.blocks.map(block => {\n            switch (block.type) {\n                case 'heading-1':\n                    return `# ${block.content}`;\n                case 'heading-2':\n                    return `## ${block.content}`;\n                case 'heading-3':\n                    return `### ${block.content}`;\n                case 'heading-4':\n                    return `#### ${block.content}`;\n                case 'heading-5':\n                    return `##### ${block.content}`;\n                case 'heading-6':\n                    return `###### ${block.content}`;\n                case 'quote':\n                    return `> ${block.content}`;\n                case 'code':\n                    const language = block.metadata?.language || '';\n                    return `\\`\\`\\`${language}\\n${block.content}\\n\\`\\`\\``;\n                case 'bullet-list':\n                    return `- ${block.content}`;\n                case 'numbered-list':\n                    return `${block.metadata?.number || 1}. ${block.content}`;\n                case 'checklist':\n                    const checked = block.metadata?.checked ? 'x' : ' ';\n                    return `- [${checked}] ${block.content}`;\n                case 'horizontal-rule':\n                    return '---';\n                case 'paragraph':\n                default:\n                    return block.content;\n            }\n        }).join('\\n\\n');\n    }\n    convertToText(content) {\n        return content.blocks.map(block => block.content).join('\\n\\n');\n    }\n    convertFromMarkdown(markdown) {\n        const lines = markdown.split('\\n');\n        const blocks = [];\n        let blockIdCounter = 0;\n        for (const line of lines) {\n            if (!line.trim())\n                continue;\n            const blockId = `block-${++blockIdCounter}`;\n            const now = new Date();\n            // Headings\n            const headingMatch = line.match(/^(#{1,6})\\s+(.*)$/);\n            if (headingMatch) {\n                blocks.push({\n                    id: blockId,\n                    type: `heading-${headingMatch[1].length}`,\n                    content: headingMatch[2],\n                    metadata: { level: headingMatch[1].length },\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Quote\n            if (line.startsWith('> ')) {\n                blocks.push({\n                    id: blockId,\n                    type: 'quote',\n                    content: line.substring(2),\n                    metadata: {},\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Code block start\n            if (line.startsWith('```')) {\n                const language = line.substring(3).trim() || 'text';\n                blocks.push({\n                    id: blockId,\n                    type: 'code',\n                    content: '', // Will be filled by subsequent lines\n                    metadata: { language },\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Bullet list\n            if (line.startsWith('- ') || line.startsWith('* ')) {\n                blocks.push({\n                    id: blockId,\n                    type: 'bullet-list',\n                    content: line.substring(2),\n                    metadata: { level: 0 },\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Numbered list\n            const numberedMatch = line.match(/^(\\d+)\\.\\s+(.*)$/);\n            if (numberedMatch) {\n                blocks.push({\n                    id: blockId,\n                    type: 'numbered-list',\n                    content: numberedMatch[2],\n                    metadata: { level: 0, number: parseInt(numberedMatch[1]) },\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Checklist\n            const checklistMatch = line.match(/^-\\s+\\[([x\\s])\\]\\s+(.*)$/);\n            if (checklistMatch) {\n                blocks.push({\n                    id: blockId,\n                    type: 'checklist',\n                    content: checklistMatch[2],\n                    metadata: { checked: checklistMatch[1] === 'x', level: 0 },\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Horizontal rule\n            if (line.trim() === '---' || line.trim() === '***') {\n                blocks.push({\n                    id: blockId,\n                    type: 'horizontal-rule',\n                    content: '',\n                    metadata: {},\n                    createdAt: now,\n                    updatedAt: now\n                });\n                continue;\n            }\n            // Default to paragraph\n            blocks.push({\n                id: blockId,\n                type: 'paragraph',\n                content: line,\n                metadata: {},\n                createdAt: now,\n                updatedAt: now\n            });\n        }\n        return {\n            blocks,\n            currentBlockId: null\n        };\n    }\n    convertFromText(text) {\n        const paragraphs = text.split('\\n\\n').filter(p => p.trim());\n        const blocks = [];\n        let blockIdCounter = 0;\n        for (const paragraph of paragraphs) {\n            const blockId = `block-${++blockIdCounter}`;\n            const now = new Date();\n            blocks.push({\n                id: blockId,\n                type: 'paragraph',\n                content: paragraph.trim(),\n                metadata: {},\n                createdAt: now,\n                updatedAt: now\n            });\n        }\n        return {\n            blocks,\n            currentBlockId: null\n        };\n    }\n    // Utility methods for file management\n    async createBackup(filename) {\n        const content = await this.load(filename);\n        if (!content) {\n            throw new Error(`Document not found: ${filename}`);\n        }\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        const backupFilename = `${filename}.backup.${timestamp}`;\n        await this.save(backupFilename, content);\n        return backupFilename;\n    }\n    async getStorageStats() {\n        const storageData = this.getStorageData();\n        const totalFiles = Object.keys(storageData).length;\n        const totalSize = JSON.stringify(storageData).length;\n        return {\n            totalFiles,\n            totalSize,\n            usage: `${(totalSize / 1024).toFixed(2)} KB`\n        };\n    }\n}\n","export class GemmaService {\n    constructor() {\n        this.isConnected = false;\n        this.baseUrl = 'http://localhost:11434/api';\n        this.modelName = 'gemma3:12b';\n    }\n    async initialize() {\n        try {\n            console.log('Initializing Gemma service...');\n            // Check if Ollama is running\n            const response = await fetch(`${this.baseUrl}/tags`);\n            if (!response.ok) {\n                throw new Error(`Ollama API not accessible: ${response.status}`);\n            }\n            const data = await response.json();\n            // Check if gemma3:27b model is available\n            const modelExists = data.models && data.models.some((model) => model.name === this.modelName || model.name.startsWith('gemma3:27b'));\n            if (!modelExists) {\n                console.warn(`Model ${this.modelName} not found. Available models:`, data.models?.map((m) => m.name));\n                throw new Error(`Model ${this.modelName} not found in Ollama. Please install it first with: ollama pull ${this.modelName}`);\n            }\n            this.isConnected = true;\n            console.log('Gemma service initialized successfully');\n        }\n        catch (error) {\n            console.error('Failed to initialize Gemma service:', error);\n            this.isConnected = false;\n            throw error;\n        }\n    }\n    async generate(prompt, options = {}) {\n        if (!this.isConnected) {\n            await this.initialize();\n        }\n        try {\n            const response = await fetch(`${this.baseUrl}/generate`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    model: this.modelName,\n                    prompt: prompt,\n                    stream: false,\n                    options: {\n                        num_predict: options.maxTokens || 256,\n                        temperature: options.temperature || 0.7,\n                        top_p: options.topP || 0.9,\n                        stop: options.stopSequences || []\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Generation failed: ${response.status}`);\n            }\n            const data = await response.json();\n            return data.response || '';\n        }\n        catch (error) {\n            console.error('Text generation failed:', error);\n            throw error;\n        }\n    }\n    async streamGenerate(prompt, callback, options = {}) {\n        if (!this.isConnected) {\n            await this.initialize();\n        }\n        try {\n            const response = await fetch(`${this.baseUrl}/generate`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    model: this.modelName,\n                    prompt: prompt,\n                    stream: true,\n                    options: {\n                        num_predict: options.maxTokens || 256,\n                        temperature: options.temperature || 0.7,\n                        top_p: options.topP || 0.9,\n                        stop: options.stopSequences || []\n                    }\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Stream generation failed: ${response.status}`);\n            }\n            const reader = response.body?.getReader();\n            if (!reader) {\n                throw new Error('Failed to get response reader');\n            }\n            const decoder = new TextDecoder();\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                const chunk = decoder.decode(value);\n                const lines = chunk.split('\\\\n').filter(line => line.trim());\n                for (const line of lines) {\n                    try {\n                        const data = JSON.parse(line);\n                        if (data.response) {\n                            callback(data.response);\n                        }\n                        if (data.done) {\n                            return;\n                        }\n                    }\n                    catch (e) {\n                        // Skip invalid JSON lines\n                        continue;\n                    }\n                }\n            }\n        }\n        catch (error) {\n            console.error('Stream generation failed:', error);\n            throw error;\n        }\n    }\n    async generateCompletion(currentText, context, referenceContext = '') {\n        // More focused prompt for inline completions like GitHub Copilot\n        const fullContext = referenceContext\n            ? `${context}\\n\\n--- Reference Materials ---\\n${referenceContext}`\n            : context;\n        const prompt = `You are an AI writing assistant. Based on the document context${referenceContext ? ' and reference materials' : ''}, provide a natural, concise continuation.\n\nDocument context:\n${fullContext}\n\nCurrent text being written: \"${currentText}\"\n\nContinue the current text naturally. Provide ONLY the continuation text (no quotes, no repetition of the current text). Keep it to 1-10 words maximum. Be concise and relevant${referenceContext ? '. Use information from reference materials when relevant' : ''}:`;\n        try {\n            const completion = await this.generate(prompt, {\n                maxTokens: 32, // Smaller for inline suggestions\n                temperature: 0.2, // Lower temperature for more predictable suggestions\n                stopSequences: ['\\n', '.', '!', '?', '\\r'] // Stop at sentence boundaries\n            });\n            // Clean up the completion\n            let cleanedCompletion = completion.trim();\n            // Remove any quotes or prefixes\n            cleanedCompletion = cleanedCompletion.replace(/^[\"']|[\"']$/g, '');\n            cleanedCompletion = cleanedCompletion.replace(/^(continue|completion|text):\\s*/i, '');\n            // Ensure it doesn't repeat the current text\n            if (cleanedCompletion.toLowerCase().startsWith(currentText.toLowerCase())) {\n                cleanedCompletion = cleanedCompletion.substring(currentText.length).trim();\n            }\n            return cleanedCompletion;\n        }\n        catch (error) {\n            console.error('Auto-completion failed:', error);\n            return '';\n        }\n    }\n    async generateFromChat(message, context = '', referenceContext = '') {\n        const fullContext = context && referenceContext\n            ? `Document context: ${context}\\n\\nReference materials: ${referenceContext}`\n            : context\n                ? `Document context: ${context}`\n                : referenceContext\n                    ? `Reference materials: ${referenceContext}`\n                    : '';\n        const prompt = fullContext\n            ? `${fullContext}\n\nUser message: ${message}\n\nProvide a helpful response using the available context and reference materials:`\n            : `User message: ${message}\n\nProvide a helpful response:`;\n        try {\n            return await this.generate(prompt, {\n                maxTokens: 512,\n                temperature: 0.7\n            });\n        }\n        catch (error) {\n            console.error('Chat generation failed:', error);\n            throw error;\n        }\n    }\n    async generateStreamFromChat(message, callback, context = '', referenceContext = '') {\n        const fullContext = context && referenceContext\n            ? `Document context: ${context}\\n\\nReference materials: ${referenceContext}`\n            : context\n                ? `Document context: ${context}`\n                : referenceContext\n                    ? `Reference materials: ${referenceContext}`\n                    : '';\n        const prompt = fullContext\n            ? `${fullContext}\n\nUser message: ${message}\n\nProvide a helpful response using the available context and reference materials:`\n            : `User message: ${message}\n\nProvide a helpful response:`;\n        try {\n            await this.streamGenerate(prompt, callback, {\n                maxTokens: 512,\n                temperature: 0.7\n            });\n        }\n        catch (error) {\n            console.error('Streaming chat generation failed:', error);\n            throw error;\n        }\n    }\n    async composeDocument(instruction, context = '', referenceContext = '') {\n        const fullContext = context && referenceContext\n            ? `Document context: ${context}\\n\\nReference materials: ${referenceContext}`\n            : context\n                ? `Document context: ${context}`\n                : referenceContext\n                    ? `Reference materials: ${referenceContext}`\n                    : '';\n        const prompt = fullContext\n            ? `${fullContext}\n\nInstruction: ${instruction}\n\nGenerate content based on the instruction, incorporating relevant information from the provided context and reference materials:`\n            : `Instruction: ${instruction}\n\nGenerate content based on the instruction:`;\n        try {\n            return await this.generate(prompt, {\n                maxTokens: 1024,\n                temperature: 0.6\n            });\n        }\n        catch (error) {\n            console.error('Document composition failed:', error);\n            throw error;\n        }\n    }\n    async streamComposeDocument(instruction, callback, context = '', referenceContext = '') {\n        const fullContext = context && referenceContext\n            ? `Document context: ${context}\\n\\nReference materials: ${referenceContext}`\n            : context\n                ? `Document context: ${context}`\n                : referenceContext\n                    ? `Reference materials: ${referenceContext}`\n                    : '';\n        const prompt = fullContext\n            ? `${fullContext}\n\nInstruction: ${instruction}\n\nGenerate content based on the instruction, incorporating relevant information from the provided context and reference materials:`\n            : `Instruction: ${instruction}\n\nGenerate content based on the instruction:`;\n        try {\n            await this.streamGenerate(prompt, callback, {\n                maxTokens: 1024,\n                temperature: 0.6\n            });\n        }\n        catch (error) {\n            console.error('Streaming document composition failed:', error);\n            throw error;\n        }\n    }\n    isReady() {\n        return this.isConnected;\n    }\n    getModelInfo() {\n        return {\n            name: this.modelName,\n            baseUrl: this.baseUrl,\n            connected: this.isConnected\n        };\n    }\n}\n","export class ChatInterface {\n    constructor(container, gemmaService, editor, referenceManager) {\n        this.messages = [];\n        this.messageIdCounter = 0;\n        this.isProcessing = false;\n        this.container = container;\n        this.gemmaService = gemmaService;\n        this.editor = editor;\n        this.referenceManager = referenceManager;\n        this.initializeElements();\n        this.setupEventListeners();\n        this.addWelcomeMessage();\n    }\n    initializeElements() {\n        this.messagesContainer = this.container.querySelector('#chat-messages');\n        this.inputElement = this.container.querySelector('#chat-input');\n        if (!this.messagesContainer || !this.inputElement) {\n            throw new Error('Chat interface elements not found');\n        }\n        // Add some styling improvements\n        this.messagesContainer.style.cssText += `\n      max-height: 400px;\n      overflow-y: auto;\n      scroll-behavior: smooth;\n    `;\n    }\n    setupEventListeners() {\n        // Handle Enter key in input\n        this.inputElement.addEventListener('keydown', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.sendMessage();\n            }\n        });\n        // Handle input focus\n        this.inputElement.addEventListener('focus', () => {\n            this.inputElement.style.borderColor = '#2196f3';\n        });\n        this.inputElement.addEventListener('blur', () => {\n            this.inputElement.style.borderColor = '#ddd';\n        });\n    }\n    addWelcomeMessage() {\n        const welcomeMessage = {\n            id: `msg-${++this.messageIdCounter}`,\n            role: 'assistant',\n            content: 'Hello! I\\'m your AI assistant powered by Gemma3. I can help you with questions and guidance. For content generation, try:\\n\\n **Inline suggestions**: Just type - gray suggestions appear automatically (press Tab to accept, Esc to dismiss)\\n **Chat commands**: \"Write a paragraph about...\" (generates directly in editor)\\n **AI command palette**: Ctrl+/ (or Cmd+/) to open quick AI commands\\n **Reference documents**: Upload .txt/.md files below - I\\'ll use them as context for better responses\\n\\nWhat can I help you with?',\n            timestamp: new Date()\n        };\n        this.messages.push(welcomeMessage);\n        this.renderMessage(welcomeMessage);\n    }\n    async sendMessage() {\n        const content = this.inputElement.value.trim();\n        if (!content || this.isProcessing)\n            return;\n        // Clear input\n        this.inputElement.value = '';\n        this.isProcessing = true;\n        // Add user message\n        const userMessage = {\n            id: `msg-${++this.messageIdCounter}`,\n            role: 'user',\n            content,\n            timestamp: new Date()\n        };\n        this.messages.push(userMessage);\n        this.renderMessage(userMessage);\n        // Create assistant message placeholder\n        const assistantMessage = {\n            id: `msg-${++this.messageIdCounter}`,\n            role: 'assistant',\n            content: '',\n            timestamp: new Date(),\n            isStreaming: true\n        };\n        this.messages.push(assistantMessage);\n        const messageElement = this.renderMessage(assistantMessage);\n        try {\n            // Get document context and reference context\n            const context = this.getDocumentContext();\n            const referenceContext = this.getReferenceContext(content);\n            // Check if this is a composer command\n            if (this.isComposerCommand(content)) {\n                await this.handleComposerCommand(content, context, referenceContext, assistantMessage, messageElement);\n            }\n            else {\n                await this.handleChatMessage(content, context, referenceContext, assistantMessage, messageElement);\n            }\n        }\n        catch (error) {\n            console.error('Chat error:', error);\n            assistantMessage.content = 'Sorry, I encountered an error processing your message. Please try again.';\n            assistantMessage.isStreaming = false;\n            this.updateMessageElement(messageElement, assistantMessage);\n        }\n        finally {\n            this.isProcessing = false;\n        }\n    }\n    async handleChatMessage(content, context, referenceContext, assistantMessage, messageElement) {\n        let fullResponse = '';\n        await this.gemmaService.generateStreamFromChat(content, (chunk) => {\n            fullResponse += chunk;\n            assistantMessage.content = fullResponse;\n            this.updateMessageElement(messageElement, assistantMessage);\n            this.scrollToBottom();\n        }, context, referenceContext);\n        assistantMessage.isStreaming = false;\n        this.updateMessageElement(messageElement, assistantMessage);\n    }\n    async handleComposerCommand(content, context, referenceContext, assistantMessage, messageElement) {\n        const instruction = this.extractInstruction(content);\n        // Show what we're doing\n        const referencesInfo = referenceContext ? ' (using reference materials)' : '';\n        assistantMessage.content = ` Generating content in your document${referencesInfo}...`;\n        assistantMessage.isStreaming = false;\n        this.updateMessageElement(messageElement, assistantMessage);\n        try {\n            // Generate content directly in the editor using streaming\n            await this.editor.streamAIContentIntoEditor(instruction);\n            // Update chat to show completion\n            assistantMessage.content = ` Content has been generated and inserted into your document!${referencesInfo ? '\\n\\n Used reference materials for context.' : ''}`;\n            this.updateMessageElement(messageElement, assistantMessage);\n        }\n        catch (error) {\n            console.error('Content generation failed:', error);\n            assistantMessage.content = ' Failed to generate content. Please try again.';\n            this.updateMessageElement(messageElement, assistantMessage);\n        }\n    }\n    isComposerCommand(content) {\n        const composerKeywords = [\n            'write', 'generate', 'create', 'compose', 'draft', 'make',\n            'help me write', 'can you write', 'please write'\n        ];\n        const lowerContent = content.toLowerCase();\n        return composerKeywords.some(keyword => lowerContent.includes(keyword));\n    }\n    extractInstruction(content) {\n        // Remove common prefixes to get the core instruction\n        return content\n            .replace(/^(write|generate|create|compose|draft|make)\\s+/i, '')\n            .replace(/^(help me|can you|please)\\s+(write|generate|create|compose|draft|make)\\s+/i, '')\n            .trim();\n    }\n    renderMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = `chat-message ${message.role}`;\n        messageElement.dataset.messageId = message.id;\n        messageElement.style.cssText = `\n      margin-bottom: 16px;\n      padding: 12px;\n      border-radius: 8px;\n      max-width: 85%;\n      word-wrap: break-word;\n      ${message.role === 'user'\n            ? 'background: #e3f2fd; margin-left: auto; text-align: right;'\n            : 'background: #f5f5f5; margin-right: auto;'}\n    `;\n        this.updateMessageElement(messageElement, message);\n        this.messagesContainer.appendChild(messageElement);\n        this.scrollToBottom();\n        return messageElement;\n    }\n    updateMessageElement(element, message) {\n        const contentElement = element.querySelector('.message-content') || (() => {\n            const content = document.createElement('div');\n            content.className = 'message-content';\n            content.style.cssText = 'line-height: 1.4; white-space: pre-wrap;';\n            element.appendChild(content);\n            return content;\n        })();\n        contentElement.textContent = message.content;\n        // Add streaming indicator\n        if (message.isStreaming) {\n            const indicator = element.querySelector('.streaming-indicator') || (() => {\n                const indicator = document.createElement('span');\n                indicator.className = 'streaming-indicator';\n                indicator.textContent = ' ';\n                indicator.style.cssText = 'color: #2196f3; animation: pulse 1s infinite;';\n                element.appendChild(indicator);\n                return indicator;\n            })();\n        }\n        else {\n            const indicator = element.querySelector('.streaming-indicator');\n            if (indicator) {\n                indicator.remove();\n            }\n        }\n        // Add timestamp\n        const timestampElement = element.querySelector('.message-timestamp') || (() => {\n            const timestamp = document.createElement('div');\n            timestamp.className = 'message-timestamp';\n            timestamp.style.cssText = 'font-size: 11px; color: #666; margin-top: 4px; opacity: 0.7;';\n            element.appendChild(timestamp);\n            return timestamp;\n        })();\n        timestampElement.textContent = message.timestamp.toLocaleTimeString();\n    }\n    scrollToBottom() {\n        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;\n    }\n    getDocumentContext() {\n        const blocks = this.editor.getBlocks();\n        return blocks.map(block => block.content).join('\\n').substring(0, 2000); // Limit context size\n    }\n    getReferenceContext(message) {\n        // Extract keywords from the user message and document context\n        const documentContext = this.getDocumentContext();\n        const allText = message + ' ' + documentContext;\n        const keywords = this.extractKeywords(allText);\n        // Get relevant reference content\n        return this.referenceManager.getRelevantContent(keywords, 1500);\n    }\n    extractKeywords(text) {\n        // Simple keyword extraction - split by words and filter meaningful ones\n        const words = text\n            .toLowerCase()\n            .replace(/[^\\w\\s]/g, ' ')\n            .split(/\\s+/)\n            .filter(word => word.length > 3) // Filter short words\n            .filter(word => !this.isStopWord(word));\n        // Return unique words, limited to avoid too much context\n        return [...new Set(words)].slice(0, 12);\n    }\n    isStopWord(word) {\n        const stopWords = new Set([\n            'this', 'that', 'with', 'have', 'will', 'from', 'they', 'been',\n            'were', 'said', 'each', 'which', 'their', 'time', 'about', 'there',\n            'could', 'other', 'more', 'very', 'what', 'know', 'just', 'first',\n            'into', 'over', 'think', 'also', 'your', 'work', 'life', 'only',\n            'new', 'would', 'come', 'its', 'after', 'way', 'who', 'may',\n            'say', 'great', 'where', 'much', 'should', 'well', 'large', 'use'\n        ]);\n        return stopWords.has(word);\n    }\n    showNotification(message) {\n        const notification = document.createElement('div');\n        notification.className = 'chat-notification';\n        notification.textContent = message;\n        notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #4caf50;\n      color: white;\n      padding: 12px 20px;\n      border-radius: 4px;\n      font-size: 14px;\n      z-index: 1001;\n      animation: slideInRight 0.3s ease;\n    `;\n        document.body.appendChild(notification);\n        setTimeout(() => {\n            notification.style.animation = 'slideOutRight 0.3s ease';\n            setTimeout(() => {\n                notification.remove();\n            }, 300);\n        }, 3000);\n    }\n    clearMessages() {\n        this.messages = [];\n        this.messagesContainer.innerHTML = '';\n        this.addWelcomeMessage();\n    }\n    getMessages() {\n        return [...this.messages];\n    }\n    addSystemMessage(content) {\n        const message = {\n            id: `msg-${++this.messageIdCounter}`,\n            role: 'assistant',\n            content,\n            timestamp: new Date()\n        };\n        this.messages.push(message);\n        this.renderMessage(message);\n    }\n}\n","export class AutoSave {\n    constructor(editor, fileStorage, options = {}) {\n        this.saveTimer = null;\n        this.lastSaveTime = null;\n        this.hasUnsavedChanges = false;\n        this.isInitialized = false;\n        this.editor = editor;\n        this.fileStorage = fileStorage;\n        this.options = {\n            interval: 30000, // 30 seconds\n            filename: 'current.json',\n            enabled: true,\n            showStatus: true,\n            ...options\n        };\n        this.initialize();\n    }\n    initialize() {\n        if (this.isInitialized)\n            return;\n        // Listen for editor changes\n        window.addEventListener('editorChange', this.handleEditorChange.bind(this));\n        // Listen for page visibility changes to save before user leaves\n        document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));\n        // Listen for beforeunload to save before page closes\n        window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));\n        // Start auto-save timer if enabled\n        if (this.options.enabled) {\n            this.startAutoSave();\n        }\n        this.isInitialized = true;\n        console.log('AutoSave initialized');\n    }\n    handleEditorChange() {\n        this.hasUnsavedChanges = true;\n        // Reset the auto-save timer\n        if (this.options.enabled) {\n            this.restartAutoSave();\n        }\n        // Update UI to show unsaved changes\n        if (this.options.showStatus) {\n            this.updateSaveStatus('unsaved');\n        }\n    }\n    handleVisibilityChange() {\n        if (document.hidden && this.hasUnsavedChanges) {\n            // Page is being hidden, save immediately\n            this.saveNow();\n        }\n    }\n    handleBeforeUnload(event) {\n        if (this.hasUnsavedChanges) {\n            // Save before page unloads\n            this.saveNow();\n            // Show warning to user\n            const message = 'You have unsaved changes. Are you sure you want to leave?';\n            event.returnValue = message;\n            return message;\n        }\n        return undefined;\n    }\n    startAutoSave() {\n        if (this.saveTimer) {\n            clearInterval(this.saveTimer);\n        }\n        this.saveTimer = setInterval(() => {\n            if (this.hasUnsavedChanges) {\n                this.saveNow();\n            }\n        }, this.options.interval);\n    }\n    restartAutoSave() {\n        if (this.options.enabled) {\n            this.startAutoSave();\n        }\n    }\n    async saveNow() {\n        if (!this.hasUnsavedChanges) {\n            return;\n        }\n        try {\n            if (this.options.showStatus) {\n                this.updateSaveStatus('saving');\n            }\n            const editorState = this.editor.getState();\n            await this.fileStorage.save(this.options.filename, editorState);\n            this.hasUnsavedChanges = false;\n            this.lastSaveTime = new Date();\n            if (this.options.showStatus) {\n                this.updateSaveStatus('saved');\n            }\n            console.log(`Auto-saved at ${this.lastSaveTime.toLocaleTimeString()}`);\n        }\n        catch (error) {\n            console.error('Auto-save failed:', error);\n            if (this.options.showStatus) {\n                this.updateSaveStatus('error');\n            }\n        }\n    }\n    enable() {\n        this.options.enabled = true;\n        this.startAutoSave();\n        console.log('Auto-save enabled');\n    }\n    disable() {\n        this.options.enabled = false;\n        if (this.saveTimer) {\n            clearInterval(this.saveTimer);\n            this.saveTimer = null;\n        }\n        console.log('Auto-save disabled');\n    }\n    setInterval(interval) {\n        this.options.interval = interval;\n        if (this.options.enabled) {\n            this.restartAutoSave();\n        }\n        console.log(`Auto-save interval set to ${interval}ms`);\n    }\n    setFilename(filename) {\n        this.options.filename = filename;\n        console.log(`Auto-save filename set to ${filename}`);\n    }\n    getStatus() {\n        return {\n            enabled: this.options.enabled,\n            interval: this.options.interval,\n            filename: this.options.filename,\n            lastSaveTime: this.lastSaveTime,\n            hasUnsavedChanges: this.hasUnsavedChanges\n        };\n    }\n    updateSaveStatus(status) {\n        // Remove existing status\n        const existingStatus = document.querySelector('.auto-save-status');\n        if (existingStatus) {\n            existingStatus.remove();\n        }\n        // Create status element\n        const statusEl = document.createElement('div');\n        statusEl.className = 'auto-save-status';\n        statusEl.style.cssText = `\n      position: fixed;\n      bottom: 20px;\n      left: 20px;\n      padding: 8px 16px;\n      border-radius: 4px;\n      font-size: 14px;\n      z-index: 1000;\n      transition: opacity 0.3s;\n    `;\n        switch (status) {\n            case 'saved':\n                statusEl.style.background = '#4caf50';\n                statusEl.style.color = 'white';\n                statusEl.textContent = ` Saved at ${new Date().toLocaleTimeString()}`;\n                break;\n            case 'saving':\n                statusEl.style.background = '#2196f3';\n                statusEl.style.color = 'white';\n                statusEl.textContent = ' Saving...';\n                break;\n            case 'unsaved':\n                statusEl.style.background = '#ff9800';\n                statusEl.style.color = 'white';\n                statusEl.textContent = ' Unsaved changes';\n                break;\n            case 'error':\n                statusEl.style.background = '#f44336';\n                statusEl.style.color = 'white';\n                statusEl.textContent = ' Save failed';\n                break;\n        }\n        document.body.appendChild(statusEl);\n        // Auto-hide success/error messages\n        if (status === 'saved' || status === 'error') {\n            setTimeout(() => {\n                statusEl.style.opacity = '0';\n                setTimeout(() => {\n                    statusEl.remove();\n                }, 300);\n            }, 3000);\n        }\n    }\n    destroy() {\n        // Clean up event listeners\n        window.removeEventListener('editorChange', this.handleEditorChange.bind(this));\n        document.removeEventListener('visibilitychange', this.handleVisibilityChange.bind(this));\n        window.removeEventListener('beforeunload', this.handleBeforeUnload.bind(this));\n        // Clear timer\n        if (this.saveTimer) {\n            clearInterval(this.saveTimer);\n            this.saveTimer = null;\n        }\n        // Save any unsaved changes before destroying\n        if (this.hasUnsavedChanges) {\n            this.saveNow();\n        }\n        this.isInitialized = false;\n        console.log('AutoSave destroyed');\n    }\n    // Manual save method for user-triggered saves\n    async manualSave(filename) {\n        const saveFilename = filename || this.options.filename;\n        try {\n            if (this.options.showStatus) {\n                this.updateSaveStatus('saving');\n            }\n            const editorState = this.editor.getState();\n            await this.fileStorage.save(saveFilename, editorState);\n            this.hasUnsavedChanges = false;\n            this.lastSaveTime = new Date();\n            if (this.options.showStatus) {\n                this.updateSaveStatus('saved');\n            }\n            console.log(`Manually saved to ${saveFilename} at ${this.lastSaveTime.toLocaleTimeString()}`);\n        }\n        catch (error) {\n            console.error('Manual save failed:', error);\n            if (this.options.showStatus) {\n                this.updateSaveStatus('error');\n            }\n            throw error;\n        }\n    }\n}\n","export class ReferenceManager {\n    constructor() {\n        this.STORAGE_KEY = 'gemma-notebook-references';\n        this.documents = [];\n        this.documentIdCounter = 0;\n        this.loadReferences();\n    }\n    async uploadFile(file) {\n        // Validate file type\n        if (!this.isValidFileType(file)) {\n            throw new Error('Invalid file type. Only .txt and .md files are supported.');\n        }\n        // Validate file size (max 1MB)\n        const maxSize = 1024 * 1024; // 1MB\n        if (file.size > maxSize) {\n            throw new Error('File too large. Maximum size is 1MB.');\n        }\n        try {\n            // Read file content\n            const content = await this.readFileContent(file);\n            // Create reference document\n            const document = {\n                id: `ref-${++this.documentIdCounter}`,\n                name: file.name,\n                content: content.trim(),\n                type: this.getFileType(file.name),\n                uploadedAt: new Date(),\n                size: file.size\n            };\n            // Add to documents list\n            this.documents.push(document);\n            // Save to storage\n            this.saveReferences();\n            return document;\n        }\n        catch (error) {\n            console.error('Failed to upload reference file:', error);\n            throw new Error(`Failed to upload file: ${file.name}`);\n        }\n    }\n    removeDocument(documentId) {\n        const index = this.documents.findIndex(doc => doc.id === documentId);\n        if (index !== -1) {\n            this.documents.splice(index, 1);\n            this.saveReferences();\n            return true;\n        }\n        return false;\n    }\n    getDocument(documentId) {\n        return this.documents.find(doc => doc.id === documentId);\n    }\n    getAllDocuments() {\n        return [...this.documents];\n    }\n    getDocumentsContent() {\n        if (this.documents.length === 0) {\n            return '';\n        }\n        const separator = '\\n\\n--- Reference Document ---\\n\\n';\n        return this.documents\n            .map(doc => `### ${doc.name}\\n\\n${doc.content}`)\n            .join(separator);\n    }\n    getDocumentsSummary() {\n        if (this.documents.length === 0) {\n            return 'No reference documents available.';\n        }\n        return `Reference documents available:\\n${this.documents\n            .map(doc => `- ${doc.name} (${doc.type}, ${this.formatFileSize(doc.size)})`)\n            .join('\\n')}`;\n    }\n    clearAllDocuments() {\n        this.documents = [];\n        this.saveReferences();\n    }\n    getStats() {\n        return {\n            totalDocuments: this.documents.length,\n            totalSize: this.documents.reduce((sum, doc) => sum + doc.size, 0),\n            types: {\n                text: this.documents.filter(doc => doc.type === 'text').length,\n                markdown: this.documents.filter(doc => doc.type === 'markdown').length\n            }\n        };\n    }\n    isValidFileType(file) {\n        const validExtensions = ['.txt', '.md', '.markdown'];\n        const fileName = file.name.toLowerCase();\n        return validExtensions.some(ext => fileName.endsWith(ext));\n    }\n    getFileType(fileName) {\n        const lowerName = fileName.toLowerCase();\n        if (lowerName.endsWith('.md') || lowerName.endsWith('.markdown')) {\n            return 'markdown';\n        }\n        return 'text';\n    }\n    async readFileContent(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = (event) => {\n                const content = event.target?.result;\n                resolve(content);\n            };\n            reader.onerror = () => {\n                reject(new Error('Failed to read file'));\n            };\n            reader.readAsText(file, 'UTF-8');\n        });\n    }\n    loadReferences() {\n        try {\n            const stored = localStorage.getItem(this.STORAGE_KEY);\n            if (stored) {\n                const data = JSON.parse(stored);\n                this.documents = data.documents.map(doc => ({\n                    ...doc,\n                    uploadedAt: new Date(doc.uploadedAt)\n                }));\n                // Update counter to avoid ID conflicts\n                this.documentIdCounter = Math.max(...this.documents.map(doc => parseInt(doc.id.split('-')[1]) || 0), 0);\n            }\n        }\n        catch (error) {\n            console.error('Failed to load references:', error);\n            this.documents = [];\n        }\n    }\n    saveReferences() {\n        try {\n            const data = {\n                documents: this.documents,\n                lastUpdated: new Date()\n            };\n            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\n        }\n        catch (error) {\n            console.error('Failed to save references:', error);\n            throw new Error('Failed to save reference documents');\n        }\n    }\n    formatFileSize(bytes) {\n        if (bytes === 0)\n            return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n    }\n    // Search within reference documents\n    searchReferences(query) {\n        const results = [];\n        const searchTerm = query.toLowerCase();\n        this.documents.forEach(doc => {\n            const lines = doc.content.split('\\n');\n            const matchingLines = [];\n            lines.forEach((line, index) => {\n                if (line.toLowerCase().includes(searchTerm)) {\n                    matchingLines.push({\n                        lineNumber: index + 1,\n                        content: line.trim()\n                    });\n                }\n            });\n            if (matchingLines.length > 0) {\n                results.push({ document: doc, matchingLines });\n            }\n        });\n        return results;\n    }\n    // Get context-relevant content from references\n    getRelevantContent(contextKeywords, maxLength = 2000) {\n        if (this.documents.length === 0)\n            return '';\n        // Simple relevance scoring based on keyword matches\n        const relevantSections = [];\n        this.documents.forEach(doc => {\n            const paragraphs = doc.content.split('\\n\\n').filter(p => p.trim());\n            paragraphs.forEach(paragraph => {\n                let score = 0;\n                const lowerParagraph = paragraph.toLowerCase();\n                contextKeywords.forEach(keyword => {\n                    const keywordLower = keyword.toLowerCase();\n                    const matches = (lowerParagraph.match(new RegExp(keywordLower, 'g')) || []).length;\n                    score += matches * keyword.length; // Weight longer keywords more\n                });\n                if (score > 0) {\n                    relevantSections.push({\n                        content: paragraph.trim(),\n                        score,\n                        source: doc.name\n                    });\n                }\n            });\n        });\n        // Sort by relevance and take top sections within length limit\n        relevantSections.sort((a, b) => b.score - a.score);\n        let result = '';\n        for (const section of relevantSections) {\n            const addition = `[From ${section.source}]\\n${section.content}\\n\\n`;\n            if (result.length + addition.length <= maxLength) {\n                result += addition;\n            }\n            else {\n                break;\n            }\n        }\n        return result.trim();\n    }\n}\n","export class ReferenceUI {\n    constructor(container, referenceManager) {\n        this.isExpanded = false;\n        this.container = container;\n        this.referenceManager = referenceManager;\n        this.createUI();\n        this.setupEventListeners();\n    }\n    createUI() {\n        const referencesSection = document.createElement('div');\n        referencesSection.className = 'references-section';\n        referencesSection.innerHTML = `\n      <div class=\"references-header\" style=\"\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        padding: 10px 0;\n        border-bottom: 1px solid #eee;\n        margin-bottom: 10px;\n        cursor: pointer;\n      \">\n        <h4 style=\"margin: 0; color: #333; font-size: 14px;\">\n           References <span class=\"ref-count\">(0)</span>\n        </h4>\n        <span class=\"expand-icon\" style=\"\n          transform: rotate(0deg);\n          transition: transform 0.2s;\n          font-size: 12px;\n          color: #666;\n        \"></span>\n      </div>\n      \n      <div class=\"references-content\" style=\"\n        max-height: 0;\n        overflow: hidden;\n        transition: max-height 0.3s ease;\n      \">\n        <div class=\"upload-area\" style=\"\n          border: 2px dashed #ddd;\n          border-radius: 6px;\n          padding: 20px;\n          text-align: center;\n          margin-bottom: 15px;\n          cursor: pointer;\n          transition: all 0.2s;\n        \">\n          <div style=\"color: #666; font-size: 14px; margin-bottom: 8px;\">\n             Drop files here or click to upload\n          </div>\n          <div style=\"color: #999; font-size: 12px;\">\n            Supports .txt and .md files (max 1MB each)\n          </div>\n          <input type=\"file\" multiple accept=\".txt,.md,.markdown\" style=\"display: none;\" class=\"file-input\">\n        </div>\n        \n        <div class=\"references-list\" style=\"\n          max-height: 200px;\n          overflow-y: auto;\n        \"></div>\n        \n        <div class=\"references-stats\" style=\"\n          font-size: 12px;\n          color: #666;\n          margin-top: 10px;\n          padding-top: 10px;\n          border-top: 1px solid #eee;\n        \"></div>\n      </div>\n    `;\n        this.container.appendChild(referencesSection);\n        this.updateUI();\n    }\n    setupEventListeners() {\n        // Toggle expand/collapse\n        const header = this.container.querySelector('.references-header');\n        header.addEventListener('click', () => {\n            this.toggleExpanded();\n        });\n        // File upload\n        const uploadArea = this.container.querySelector('.upload-area');\n        const fileInput = this.container.querySelector('.file-input');\n        uploadArea.addEventListener('click', () => {\n            fileInput.click();\n        });\n        uploadArea.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            uploadArea.style.borderColor = '#2196f3';\n            uploadArea.style.backgroundColor = '#f8f9ff';\n        });\n        uploadArea.addEventListener('dragleave', () => {\n            uploadArea.style.borderColor = '#ddd';\n            uploadArea.style.backgroundColor = 'transparent';\n        });\n        uploadArea.addEventListener('drop', (e) => {\n            e.preventDefault();\n            uploadArea.style.borderColor = '#ddd';\n            uploadArea.style.backgroundColor = 'transparent';\n            const files = Array.from(e.dataTransfer?.files || []);\n            this.handleFileUpload(files);\n        });\n        fileInput.addEventListener('change', (e) => {\n            const files = Array.from(e.target.files || []);\n            this.handleFileUpload(files);\n        });\n    }\n    toggleExpanded() {\n        this.isExpanded = !this.isExpanded;\n        const content = this.container.querySelector('.references-content');\n        const icon = this.container.querySelector('.expand-icon');\n        if (this.isExpanded) {\n            content.style.maxHeight = '400px';\n            icon.style.transform = 'rotate(180deg)';\n        }\n        else {\n            content.style.maxHeight = '0';\n            icon.style.transform = 'rotate(0deg)';\n        }\n    }\n    async handleFileUpload(files) {\n        const uploadPromises = files.map(async (file) => {\n            try {\n                await this.referenceManager.uploadFile(file);\n                this.showNotification(` Uploaded: ${file.name}`, 'success');\n            }\n            catch (error) {\n                console.error('Upload failed:', error);\n                this.showNotification(` Failed: ${file.name} - ${error.message}`, 'error');\n            }\n        });\n        await Promise.all(uploadPromises);\n        this.updateUI();\n        // Expand if collapsed and files were uploaded\n        if (!this.isExpanded && files.length > 0) {\n            this.toggleExpanded();\n        }\n    }\n    updateUI() {\n        this.updateReferencesList();\n        this.updateStats();\n        this.updateCount();\n    }\n    updateReferencesList() {\n        const listContainer = this.container.querySelector('.references-list');\n        const documents = this.referenceManager.getAllDocuments();\n        if (documents.length === 0) {\n            listContainer.innerHTML = `\n        <div style=\"\n          text-align: center;\n          color: #999;\n          font-size: 13px;\n          padding: 20px;\n        \">\n          No reference documents uploaded yet\n        </div>\n      `;\n            return;\n        }\n        listContainer.innerHTML = documents\n            .map(doc => this.createDocumentElement(doc))\n            .join('');\n        // Add event listeners for remove buttons\n        listContainer.querySelectorAll('.remove-btn').forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                const docId = btn.dataset.docId;\n                if (docId) {\n                    this.removeDocument(docId);\n                }\n            });\n        });\n        // Add event listeners for document items\n        listContainer.querySelectorAll('.reference-item').forEach(item => {\n            item.addEventListener('click', () => {\n                const docId = item.dataset.docId;\n                if (docId) {\n                    this.showDocumentPreview(docId);\n                }\n            });\n        });\n    }\n    createDocumentElement(doc) {\n        const icon = doc.type === 'markdown' ? '' : '';\n        const truncatedContent = doc.content.length > 100\n            ? doc.content.substring(0, 100) + '...'\n            : doc.content;\n        return `\n      <div class=\"reference-item\" data-doc-id=\"${doc.id}\" style=\"\n        padding: 8px;\n        margin-bottom: 6px;\n        background: #f8f9fa;\n        border-radius: 4px;\n        cursor: pointer;\n        position: relative;\n        transition: background-color 0.2s;\n      \" onmouseover=\"this.style.backgroundColor='#f0f0f0'\" \n         onmouseout=\"this.style.backgroundColor='#f8f9fa'\">\n        <div style=\"display: flex; align-items: center; justify-content: space-between;\">\n          <div style=\"flex: 1; min-width: 0;\">\n            <div style=\"\n              font-size: 13px;\n              font-weight: 500;\n              color: #333;\n              margin-bottom: 2px;\n              display: flex;\n              align-items: center;\n              gap: 6px;\n            \">\n              <span>${icon}</span>\n              <span style=\"white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\">\n                ${doc.name}\n              </span>\n            </div>\n            <div style=\"\n              font-size: 11px;\n              color: #666;\n              white-space: nowrap;\n              overflow: hidden;\n              text-overflow: ellipsis;\n            \">\n              ${truncatedContent}\n            </div>\n          </div>\n          <button class=\"remove-btn\" data-doc-id=\"${doc.id}\" style=\"\n            background: #ff4444;\n            color: white;\n            border: none;\n            border-radius: 3px;\n            padding: 2px 6px;\n            font-size: 10px;\n            cursor: pointer;\n            margin-left: 8px;\n            opacity: 0.7;\n          \" onmouseover=\"this.style.opacity='1'\" \n             onmouseout=\"this.style.opacity='0.7'\"></button>\n        </div>\n      </div>\n    `;\n    }\n    updateStats() {\n        const statsContainer = this.container.querySelector('.references-stats');\n        const stats = this.referenceManager.getStats();\n        if (stats.totalDocuments === 0) {\n            statsContainer.innerHTML = '';\n            return;\n        }\n        const sizeFormatted = this.formatFileSize(stats.totalSize);\n        statsContainer.innerHTML = `\n       ${stats.totalDocuments} document${stats.totalDocuments > 1 ? 's' : ''} \n       ${sizeFormatted} total\n      ${stats.types.markdown > 0 ? ` ${stats.types.markdown} markdown` : ''}\n      ${stats.types.text > 0 ? ` ${stats.types.text} text` : ''}\n    `;\n    }\n    updateCount() {\n        const countElement = this.container.querySelector('.ref-count');\n        const count = this.referenceManager.getAllDocuments().length;\n        countElement.textContent = `(${count})`;\n    }\n    removeDocument(docId) {\n        const doc = this.referenceManager.getDocument(docId);\n        if (doc && confirm(`Remove \"${doc.name}\" from references?`)) {\n            this.referenceManager.removeDocument(docId);\n            this.updateUI();\n            this.showNotification(` Removed: ${doc.name}`, 'info');\n        }\n    }\n    showDocumentPreview(docId) {\n        const doc = this.referenceManager.getDocument(docId);\n        if (!doc)\n            return;\n        const modal = document.createElement('div');\n        modal.className = 'document-preview-modal';\n        modal.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background: rgba(0,0,0,0.5);\n      z-index: 2000;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 20px;\n    `;\n        const content = document.createElement('div');\n        content.style.cssText = `\n      background: white;\n      border-radius: 8px;\n      padding: 20px;\n      max-width: 600px;\n      max-height: 80vh;\n      overflow: auto;\n      position: relative;\n    `;\n        content.innerHTML = `\n      <div style=\"\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 15px;\n        padding-bottom: 10px;\n        border-bottom: 1px solid #eee;\n      \">\n        <h3 style=\"margin: 0; color: #333;\">\n          ${doc.type === 'markdown' ? '' : ''} ${doc.name}\n        </h3>\n        <button class=\"close-btn\" style=\"\n          background: none;\n          border: none;\n          font-size: 20px;\n          cursor: pointer;\n          color: #666;\n          padding: 5px;\n        \"></button>\n      </div>\n      <div style=\"\n        font-size: 12px;\n        color: #666;\n        margin-bottom: 15px;\n      \">\n        Uploaded: ${doc.uploadedAt.toLocaleDateString()}  \n        Size: ${this.formatFileSize(doc.size)}  \n        Type: ${doc.type}\n      </div>\n      <pre style=\"\n        white-space: pre-wrap;\n        font-family: inherit;\n        font-size: 14px;\n        line-height: 1.5;\n        color: #333;\n        margin: 0;\n        background: #f8f9fa;\n        padding: 15px;\n        border-radius: 4px;\n        max-height: 400px;\n        overflow-y: auto;\n      \">${doc.content}</pre>\n    `;\n        modal.appendChild(content);\n        document.body.appendChild(modal);\n        // Close handlers\n        const closeModal = () => modal.remove();\n        content.querySelector('.close-btn')?.addEventListener('click', closeModal);\n        modal.addEventListener('click', (e) => {\n            if (e.target === modal)\n                closeModal();\n        });\n    }\n    showNotification(message, type) {\n        const notification = document.createElement('div');\n        notification.textContent = message;\n        notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      padding: 10px 15px;\n      border-radius: 4px;\n      font-size: 13px;\n      z-index: 1001;\n      max-width: 300px;\n      box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n      ${type === 'success' ? 'background: #4caf50; color: white;' : ''}\n      ${type === 'error' ? 'background: #f44336; color: white;' : ''}\n      ${type === 'info' ? 'background: #2196f3; color: white;' : ''}\n    `;\n        document.body.appendChild(notification);\n        setTimeout(() => {\n            notification.style.opacity = '0';\n            notification.style.transform = 'translateX(100%)';\n            setTimeout(() => notification.remove(), 300);\n        }, 3000);\n    }\n    formatFileSize(bytes) {\n        if (bytes === 0)\n            return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n    }\n    refresh() {\n        this.updateUI();\n    }\n    expandSection() {\n        if (!this.isExpanded) {\n            this.toggleExpanded();\n        }\n    }\n    getReferencesCount() {\n        return this.referenceManager.getAllDocuments().length;\n    }\n}\n","import { Editor } from '@/editor/Editor';\nimport { FileStorage } from '@/storage/FileStorage';\nimport { GemmaService } from '@/ai/GemmaService';\nimport { ChatInterface } from '@/chat/ChatInterface';\nimport { AutoSave } from '@/features/AutoSave';\nimport { ReferenceManager } from '@/references/ReferenceManager';\nimport { ReferenceUI } from '@/references/ReferenceUI';\nclass App {\n    constructor() {\n        this.initializeApp();\n    }\n    async initializeApp() {\n        try {\n            // Initialize core services\n            this.fileStorage = new FileStorage();\n            this.gemmaService = new GemmaService();\n            this.referenceManager = new ReferenceManager();\n            // Initialize editor\n            const editorContainer = document.querySelector('.editor-container');\n            this.editor = new Editor(editorContainer, this.gemmaService, this.referenceManager);\n            // Initialize chat interface\n            const chatContainer = document.querySelector('.chat-container');\n            this.chatInterface = new ChatInterface(chatContainer, this.gemmaService, this.editor, this.referenceManager);\n            // Initialize reference UI\n            const referenceContainer = document.getElementById('reference-container');\n            this.referenceUI = new ReferenceUI(referenceContainer, this.referenceManager);\n            // Initialize auto-save\n            this.autoSave = new AutoSave(this.editor, this.fileStorage);\n            // Connect services\n            await this.gemmaService.initialize();\n            // Load existing document if available\n            await this.loadDocument();\n            this.showStatus('App initialized successfully', 'success');\n        }\n        catch (error) {\n            console.error('Failed to initialize app:', error);\n            this.showStatus('Failed to initialize app', 'error');\n        }\n    }\n    async loadDocument() {\n        try {\n            const content = await this.fileStorage.load('current.json');\n            if (content) {\n                this.editor.loadContent(content);\n            }\n        }\n        catch (error) {\n            console.warn('No existing document found, starting with empty editor');\n        }\n    }\n    showStatus(message, type = 'success') {\n        const existing = document.querySelector('.status');\n        if (existing) {\n            existing.remove();\n        }\n        const status = document.createElement('div');\n        status.className = `status ${type}`;\n        status.textContent = message;\n        document.body.appendChild(status);\n        setTimeout(() => {\n            status.remove();\n        }, 3000);\n    }\n}\n// Initialize app when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Create app structure\n    const appDiv = document.getElementById('app');\n    if (appDiv) {\n        appDiv.innerHTML = `\n      <div class=\"app\">\n        <div class=\"editor-container\">\n          <div class=\"editor\" id=\"editor\"></div>\n        </div>\n        <div class=\"sidebar\">\n          <div class=\"reference-section\">\n            <h3> Reference Documents</h3>\n            <div class=\"reference-container\" id=\"reference-container\">\n              <!-- Reference UI will be inserted here -->\n            </div>\n          </div>\n          <div class=\"chat-section\">\n            <h3> AI Chat</h3>\n            <div class=\"chat-container\">\n              <div class=\"chat-messages\" id=\"chat-messages\"></div>\n              <div class=\"chat-input\">\n                <input type=\"text\" id=\"chat-input\" placeholder=\"Ask AI anything...\">\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"ai-help\" title=\"AI Features:&#10; Type to get inline suggestions (Tab to accept)&#10; Press Ctrl+/ for AI command palette&#10; Chat with AI in the sidebar&#10; Upload reference documents for context\">\n         AI Helper\n      </div>\n    `;\n    }\n    // Initialize the app\n    new App();\n});\n"],"names":["BlockFactory","createBlock","id","type","content","metadata","now","Date","this","getDefaultMetadata","createdAt","updatedAt","level","language","number","checked","isTextBlock","includes","isListBlock","isHeadingBlock","startsWith","getHeadingLevel","parseInt","split","BlockRenderer","render","block","blockElement","document","createElement","className","dataset","blockId","blockType","draggable","topIndicator","appendChild","bottomIndicator","menu","createBlockMenu","typeIndicator","textContent","getBlockTypeLabel","dragHandle","innerHTML","title","contentElement","createContentElement","addButton","createParagraphElement","createHeadingElement","createQuoteElement","createCodeElement","createBulletListElement","createNumberedListElement","createChecklistElement","createHorizontalRuleElement","element","contentEditable","setAttribute","wrapper","languageSelect","style","cssText","forEach","lang","option","value","selected","codeElement","code","addEventListener","marker","checkbox","textDecoration","color","hr","applyTextFormatting","formattedContent","replace","InlineSuggestion","constructor","gemmaService","referenceManager","currentSuggestion","suggestionTimeout","isGenerating","SUGGESTION_DELAY","requestSuggestion","currentText","documentContext","clearSuggestion","clearTimeout","trim","length","setTimeout","async","generateSuggestion","contextKeywords","extractKeywords","referenceContext","getRelevantContent","suggestion","generateCompletion","cleanSuggestion","showInlineSuggestion","error","console","rawSuggestion","substring","words","slice","join","originalText","suggestionElement","createSuggestionElement","querySelector","positionSuggestionElement","isActive","opacity","body","requestAnimationFrame","transition","selection","window","getSelection","rangeCount","rect","getRangeAt","getBoundingClientRect","left","top","acceptSuggestion","newText","event","CustomEvent","detail","dispatchEvent","remove","hasSuggestion","getCurrentSuggestion","updateSuggestionPosition","isSuggestionValid","destroy","text","toLowerCase","filter","word","isStopWord","Set","has","DragAndDrop","editor","editorElement","draggedElement","draggedBlockId","isDragging","startY","startX","setupEventListeners","handleMouseDown","bind","handleMouseMove","handleMouseUp","target","closest","preventDefault","stopPropagation","clientY","clientX","classList","add","deltaY","Math","abs","deltaX","cursor","userSelect","hoveredElement","getBlockElementUnderCursor","clearDragOverClasses","midPoint","height","cleanup","targetElement","targetBlockId","insertAbove","moveBlock","x","y","originalDisplay","display","elementUnder","elementFromPoint","undefined","querySelectorAll","blocks","getBlocks","draggedIndex","findIndex","b","targetIndex","newIndex","Editor","container","currentBlockId","blockIdCounter","blockFactory","blockRenderer","inlineSuggestion","initializeEditor","setupSuggestionHandlers","dragAndDrop","addBlock","handleKeyDown","handleInput","handleClick","customEvent","updateBlock","focusBlock","key","handleEnterKey","shiftKey","handleBackspaceKey","handleArrowKey","handleTab","ctrlKey","metaKey","showAICommandPalette","inputEvent","getBlockById","newContent","handleMarkdownShortcuts","inputType","data","context","getDocumentContext","notifyChange","setCurrentBlock","execCommand","range","beforeCursor","startContainer","startOffset","afterCursor","updateBlockElement","currentBlockIndex","newBlockId","blockIndex","removeBlock","prevBlock","direction","log","headingMatch","match","numberedMatch","index","splice","push","renderBlock","updates","Object","assign","currentIndex","rerenderEditor","children","insertBefore","newElement","replaceWith","find","position","focus","createRange","selectNodeContents","collapse","setStart","removeAllRanges","addRange","map","getReferenceContext","instruction","allText","keywords","getState","loadContent","state","max","showAutoCompletionNotification","message","notification","animation","parentNode","insertAIGeneratedContent","insertAtCurrentBlock","insertIndex","loadingBlockId","generatedContent","composeDocument","insertGeneratedContentAsBlocks","startIndex","lines","line","trimmedLine","blockContent","streamAIContentIntoEditor","streamingBlockId","accumulatedContent","streamComposeDocument","chunk","scrollIntoView","behavior","palette","input","placeholder","buttonsContainer","generateButton","cancelButton","handleGenerate","removeChild","handleCancel","e","FileStorage","storageKey","metadataKey","save","filename","serializedContent","JSON","stringify","storageData","getStorageData","localStorage","setItem","updateMetadata","Error","load","parse","removeMetadata","exists","list","getMetadata","values","sort","a","getTime","format","convertToMarkdown","convertToText","import","convertFromMarkdown","convertFromText","getItem","file","size","name","path","markdown","checklistMatch","paragraphs","p","paragraph","createBackup","backupFilename","toISOString","getStorageStats","totalFiles","keys","totalSize","usage","toFixed","GemmaService","isConnected","baseUrl","modelName","initialize","response","fetch","ok","status","json","models","some","model","warn","m","generate","prompt","options","method","headers","stream","num_predict","maxTokens","temperature","top_p","topP","stop","stopSequences","streamGenerate","callback","reader","getReader","decoder","TextDecoder","done","read","decode","cleanedCompletion","generateFromChat","fullContext","generateStreamFromChat","isReady","getModelInfo","connected","ChatInterface","messages","messageIdCounter","isProcessing","initializeElements","addWelcomeMessage","messagesContainer","inputElement","sendMessage","borderColor","welcomeMessage","role","timestamp","renderMessage","userMessage","assistantMessage","isStreaming","messageElement","isComposerCommand","handleComposerCommand","handleChatMessage","updateMessageElement","fullResponse","scrollToBottom","extractInstruction","referencesInfo","lowerContent","keyword","messageId","indicator","toLocaleTimeString","scrollTop","scrollHeight","showNotification","clearMessages","getMessages","addSystemMessage","AutoSave","fileStorage","saveTimer","lastSaveTime","hasUnsavedChanges","isInitialized","interval","enabled","showStatus","handleEditorChange","handleVisibilityChange","handleBeforeUnload","startAutoSave","restartAutoSave","updateSaveStatus","hidden","saveNow","returnValue","clearInterval","setInterval","editorState","enable","disable","setFilename","getStatus","existingStatus","statusEl","background","removeEventListener","manualSave","saveFilename","ReferenceManager","STORAGE_KEY","documents","documentIdCounter","loadReferences","uploadFile","isValidFileType","readFileContent","getFileType","uploadedAt","saveReferences","removeDocument","documentId","doc","getDocument","getAllDocuments","getDocumentsContent","getDocumentsSummary","formatFileSize","clearAllDocuments","getStats","totalDocuments","reduce","sum","types","fileName","ext","endsWith","lowerName","Promise","resolve","reject","FileReader","onload","result","onerror","readAsText","stored","lastUpdated","bytes","i","floor","parseFloat","pow","searchReferences","query","results","searchTerm","matchingLines","lineNumber","maxLength","relevantSections","score","lowerParagraph","keywordLower","matches","RegExp","source","section","addition","ReferenceUI","isExpanded","createUI","referencesSection","updateUI","toggleExpanded","uploadArea","fileInput","click","backgroundColor","files","Array","from","dataTransfer","handleFileUpload","icon","maxHeight","transform","uploadPromises","all","updateReferencesList","updateStats","updateCount","listContainer","createDocumentElement","btn","docId","item","showDocumentPreview","truncatedContent","statsContainer","stats","sizeFormatted","countElement","count","confirm","modal","toLocaleDateString","closeModal","refresh","expandSection","getReferencesCount","App","initializeApp","editorContainer","chatContainer","chatInterface","referenceContainer","getElementById","referenceUI","autoSave","loadDocument","existing","appDiv"],"sourceRoot":""}