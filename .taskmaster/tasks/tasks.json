{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup TypeScript Project Structure",
        "description": "Initialize a TypeScript project with necessary configurations and dependencies for a WYSIWYG note-taking application.",
        "details": "1. Create a new project directory\n2. Initialize npm project with `npm init -y`\n3. Install TypeScript: `npm install typescript --save-dev`\n4. Configure tsconfig.json with appropriate settings:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"jsx\": \"react\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n5. Setup build scripts in package.json\n6. Configure linting and formatting tools (ESLint, Prettier)\n7. Setup basic folder structure:\n   - src/\n     - components/\n     - services/\n     - utils/\n     - types/\n     - assets/\n8. Create initial index.html and entry point files",
        "testStrategy": "Verify project setup by running a test build and ensuring TypeScript compilation works correctly. Check that all dependencies are properly installed and the project structure follows best practices.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Block-Based Editor Core",
        "description": "Create the core functionality for a Notion-like block-based editor that allows users to create, edit, and manage content blocks with Markdown-like features.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Research and select an appropriate editor framework (e.g., Slate.js, ProseMirror, or build custom)\n2. Implement the basic editor component structure:\n```typescript\ninterface Block {\n  id: string;\n  type: 'paragraph' | 'heading' | 'quote' | 'code' | 'bulletList' | 'numberedList' | 'checklist' | 'horizontalRule';\n  content: any;\n  // Additional metadata\n}\n\nclass Editor {\n  private blocks: Block[];\n  \n  constructor() {\n    this.blocks = [];\n  }\n  \n  addBlock(type: Block['type'], content?: any): Block {\n    // Implementation\n  }\n  \n  removeBlock(id: string): void {\n    // Implementation\n  }\n  \n  updateBlock(id: string, updates: Partial<Block>): void {\n    // Implementation\n  }\n  \n  moveBlock(id: string, targetIndex: number): void {\n    // Implementation for reordering blocks\n  }\n  \n  render(): void {\n    // Implementation\n  }\n}\n```\n3. Implement TEXT BLOCKS:\n   - Paragraph block for basic text content\n   - Heading blocks (H1-H6) with proper hierarchy\n   - Quote/Blockquote block for indented quoted text\n   - Code block with syntax highlighting and language selection\n\n4. Implement FORMATTING FEATURES:\n   - Bold formatting (**text**)\n   - Italic formatting (*text*)\n   - Strikethrough formatting (~~text~~)\n   - Inline code formatting (`code`)\n   - Link formatting ([text](url))\n\n5. Implement LIST BLOCKS:\n   - Bullet list block (unordered lists)\n   - Numbered list block (ordered lists)\n   - Checklist/Todo block with interactive checkboxes\n\n6. Implement STRUCTURAL BLOCKS:\n   - Horizontal rule block (divider line)\n   - Line break handling\n\n7. Create block manipulation functions (add, delete, move, split, merge)\n8. Implement cursor and selection management\n9. Setup event handling for user interactions",
        "testStrategy": "Create unit tests for each block type and editor operation. Test block creation, deletion, updating, and rendering. Test specific Markdown-like formatting features (bold, italic, strikethrough, inline code, links). Test list functionality including interactive checkboxes. Implement integration tests to verify user interactions work correctly, including block reordering. Manually test the editor to ensure it behaves like expected block-based editors with proper WYSIWYG functionality.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research and select editor framework",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement basic editor component structure",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement text blocks (paragraph, heading, quote, code)",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement text formatting features (bold, italic, strikethrough, inline code, links)",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement list blocks (bullet, numbered, checklist)",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement structural blocks (horizontal rule, line breaks)",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create block manipulation functions",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement cursor and selection management",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Setup event handling for user interactions",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Local File Storage System",
        "description": "Create a system to save and load notes as files in the local filesystem.",
        "details": "1. Research appropriate file system APIs for browser/desktop environment\n2. Design the file storage service:\n```typescript\ninterface NoteMetadata {\n  id: string;\n  title: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface Note extends NoteMetadata {\n  content: Block[];\n}\n\nclass FileStorageService {\n  async saveNote(note: Note): Promise<void> {\n    // Implementation to save note to local filesystem\n  }\n  \n  async loadNote(id: string): Promise<Note> {\n    // Implementation to load note from local filesystem\n  }\n  \n  async listNotes(): Promise<NoteMetadata[]> {\n    // Implementation to list all available notes\n  }\n  \n  async deleteNote(id: string): Promise<void> {\n    // Implementation to delete a note\n  }\n}\n```\n3. Implement file format and serialization/deserialization logic\n4. Add error handling for file operations\n5. Implement file path management\n6. Create utility functions for file naming and organization",
        "testStrategy": "Test file saving and loading with various note sizes and content types. Verify data integrity by comparing saved and loaded notes. Test error scenarios such as missing files, permission issues, and storage limitations. Create mock filesystem for unit testing.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Auto-Save Functionality",
        "description": "Create an auto-save system that automatically saves user's notes at regular intervals and on specific events.",
        "details": "1. Design the auto-save service:\n```typescript\nclass AutoSaveService {\n  private editor: Editor;\n  private storage: FileStorageService;\n  private interval: number; // milliseconds\n  private timer: NodeJS.Timeout | null = null;\n  private lastSavedContent: string = '';\n  \n  constructor(editor: Editor, storage: FileStorageService, interval = 5000) {\n    this.editor = editor;\n    this.storage = storage;\n    this.interval = interval;\n  }\n  \n  start(): void {\n    // Start auto-save timer\n    this.timer = setInterval(() => this.save(), this.interval);\n    \n    // Add event listeners for specific save triggers\n    document.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('beforeunload', this.save);\n  }\n  \n  stop(): void {\n    // Stop auto-save timer and remove event listeners\n  }\n  \n  private handleKeyDown(event: KeyboardEvent): void {\n    // Save on Ctrl+S or specific events\n  }\n  \n  private async save(): Promise<void> {\n    // Get current content and compare with last saved\n    // Save only if content has changed\n  }\n}\n```\n2. Implement debouncing to prevent excessive saves during rapid editing\n3. Add visual indicators for save status (saved, saving, unsaved changes)\n4. Implement conflict resolution for cases where the file might have been modified externally\n5. Add recovery mechanism for unsaved changes in case of crashes",
        "testStrategy": "Test auto-save triggers with different editing patterns. Verify save frequency and debouncing behavior. Test recovery from simulated crashes. Measure performance impact of auto-save on editing experience. Test with various note sizes to ensure performance remains acceptable.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate Gemma SLM Model",
        "description": "Integrate the Gemma3:27b SLM (Small Language Model) from Ollama for local AI capabilities within the note-taking application.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Set up connection to local Ollama API endpoint for the gemma3:27b model\n2. Create a service for model connection and management:\n```typescript\nclass GemmaService {\n  private isConnected: boolean = false;\n  private baseUrl: string = 'http://localhost:11434/api';\n  private modelName: string = 'gemma3:27b';\n  \n  async initialize(): Promise<void> {\n    // Connect to the Ollama API and verify gemma3:27b model is available\n    try {\n      const response = await fetch(`${this.baseUrl}/tags`);\n      const data = await response.json();\n      \n      if (!data.models || !data.models.some(model => model.name === this.modelName)) {\n        throw new Error(`Model ${this.modelName} not found in Ollama. Please install it first.`);\n      }\n      \n      this.isConnected = true;\n    } catch (error) {\n      console.error('Failed to connect to Ollama API:', error);\n      throw error;\n    }\n  }\n  \n  async generate(prompt: string, options?: GenerationOptions): Promise<string> {\n    if (!this.isConnected) {\n      await this.initialize();\n    }\n    \n    // Generate text using the Ollama API\n    const response = await fetch(`${this.baseUrl}/generate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: this.modelName,\n        prompt: prompt,\n        max_tokens: options?.maxTokens || 256,\n        temperature: options?.temperature || 0.7,\n        top_p: options?.topP || 0.9,\n        stop: options?.stopSequences || []\n      })\n    });\n    \n    const data = await response.json();\n    return data.response;\n  }\n  \n  async streamGenerate(prompt: string, callback: (text: string) => void, options?: GenerationOptions): Promise<void> {\n    if (!this.isConnected) {\n      await this.initialize();\n    }\n    \n    // Stream generation results using Ollama API\n    const response = await fetch(`${this.baseUrl}/generate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: this.modelName,\n        prompt: prompt,\n        max_tokens: options?.maxTokens || 256,\n        temperature: options?.temperature || 0.7,\n        top_p: options?.topP || 0.9,\n        stop: options?.stopSequences || [],\n        stream: true\n      })\n    });\n    \n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    \n    while (true) {\n      const {done, value} = await reader.read();\n      if (done) break;\n      \n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n').filter(line => line.trim());\n      \n      for (const line of lines) {\n        const data = JSON.parse(line);\n        if (data.response) {\n          callback(data.response);\n        }\n      }\n    }\n  }\n}\n\ninterface GenerationOptions {\n  maxTokens?: number;\n  temperature?: number;\n  topP?: number;\n  stopSequences?: string[];\n}\n```\n3. Implement error handling and fallback mechanisms for Ollama connection issues\n4. Create utility functions for prompt engineering specific to gemma3:27b model\n5. Add configuration options for model parameters\n6. Create setup instructions for installing and running Ollama with gemma3:27b model\n7. Implement connection status monitoring and reconnection logic",
        "testStrategy": "Test connection to Ollama API and verify gemma3:27b model availability. Test text generation with various prompts through the Ollama API. Measure performance metrics like response time and generation speed. Test error handling with network issues, API errors, and invalid inputs. Verify model output quality for different use cases. Test reconnection logic when Ollama service restarts. Verify proper handling of streaming responses.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Ollama with gemma3:27b model",
            "description": "Install Ollama and download the gemma3:27b model for local use",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Ollama API connection service",
            "description": "Create service to connect to local Ollama API endpoint and manage the connection",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement text generation methods",
            "description": "Create methods to generate text and stream responses from the gemma3:27b model via Ollama API",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add error handling and reconnection logic",
            "description": "Implement robust error handling for API connection issues and automatic reconnection",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create configuration interface",
            "description": "Develop configuration options for model parameters and API connection settings",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Auto-Completion Feature",
        "description": "Create an auto-completion feature that suggests text completions based on the document context using the Gemma SLM model.",
        "details": "1. Design the auto-completion service:\n```typescript\nclass AutoCompletionService {\n  private editor: Editor;\n  private gemmaService: GemmaService;\n  private isEnabled: boolean = true;\n  \n  constructor(editor: Editor, gemmaService: GemmaService) {\n    this.editor = editor;\n    this.gemmaService = gemmaService;\n  }\n  \n  \n  enable(): void {\n    this.isEnabled = true;\n    this.attachListeners();\n  }\n  \n  disable(): void {\n    this.isEnabled = false;\n    this.detachListeners();\n  }\n  \n  private attachListeners(): void {\n    // Listen for typing events and cursor movements\n  }\n  \n  private detachListeners(): void {\n    // Remove event listeners\n  }\n  \n  private async getSuggestions(context: string): Promise<string> {\n    // Get text suggestions from Gemma model based on context\n    const prompt = this.buildPrompt(context);\n    return this.gemmaService.generate(prompt, {\n      maxTokens: 50,\n      temperature: 0.3,\n      topP: 0.9\n    });\n  }\n  \n  private buildPrompt(context: string): string {\n    // Create an effective prompt for auto-completion\n    return `Complete the following text in a natural way:\\n\\n${context}`;\n  }\n  \n  private showSuggestion(suggestion: string): void {\n    // Display suggestion in the editor\n  }\n  \n  private acceptSuggestion(): void {\n    // Accept the current suggestion\n  }\n}\n```\n2. Implement context extraction from the document\n3. Create UI components for displaying suggestions\n4. Add keyboard shortcuts for accepting/rejecting suggestions\n5. Implement suggestion filtering and ranking\n6. Add user preference settings for auto-completion behavior",
        "testStrategy": "Test auto-completion with various document contexts and writing styles. Measure suggestion quality and relevance. Test performance impact during typing. Verify keyboard shortcuts and UI interactions. Test with different user preferences and settings. Conduct user testing to gather feedback on suggestion quality and timing.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement AI Chat Interface",
        "description": "Create a chat interface that allows users to interact with the Gemma SLM model for assistance and document generation.",
        "details": "1. Design and implement the chat UI component:\n```typescript\ninterface ChatMessage {\n  id: string;\n  role: 'user' | 'assistant';\n  content: string;\n  timestamp: Date;\n}\n\nclass ChatInterface {\n  private messages: ChatMessage[] = [];\n  private gemmaService: GemmaService;\n  private isGenerating: boolean = false;\n  \n  constructor(gemmaService: GemmaService) {\n    this.gemmaService = gemmaService;\n  }\n  \n  async sendMessage(content: string): Promise<void> {\n    // Add user message\n    this.addMessage('user', content);\n    \n    // Generate response\n    this.isGenerating = true;\n    try {\n      await this.gemmaService.streamGenerate(\n        this.buildPrompt(),\n        (text) => this.updateAssistantMessage(text)\n      );\n    } catch (error) {\n      console.error('Error generating response:', error);\n      this.addMessage('assistant', 'Sorry, I encountered an error.');\n    } finally {\n      this.isGenerating = false;\n    }\n  }\n  \n  private addMessage(role: ChatMessage['role'], content: string): void {\n    // Add message to the chat history\n  }\n  \n  private updateAssistantMessage(content: string): void {\n    // Update the current assistant message with streaming content\n  }\n  \n  private buildPrompt(): string {\n    // Convert chat history to a prompt for the model\n  }\n  \n  render(): HTMLElement {\n    // Render the chat interface\n  }\n}\n```\n2. Implement message history management\n3. Create UI for chat input and message display\n4. Add support for markdown formatting in messages\n5. Implement streaming responses for real-time feedback\n6. Add chat context management to maintain conversation history\n7. Create UI controls for clearing chat and starting new conversations",
        "testStrategy": "Test chat interface with various user inputs and conversation flows. Verify streaming response functionality. Test markdown rendering in messages. Measure response time and quality. Test error handling during generation. Conduct user testing to evaluate the chat experience and interface usability.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Document Composer Feature",
        "description": "Create a document composer that generates content based on user instructions through the chat interface, with real-time feedback and human-in-the-loop capabilities.",
        "details": "1. Design the document composer service:\n```typescript\ninterface ComposerOptions {\n  showGenerationSteps: boolean;\n  allowHumanInterruption: boolean;\n}\n\nclass DocumentComposer {\n  private editor: Editor;\n  private chatInterface: ChatInterface;\n  private gemmaService: GemmaService;\n  private isGenerating: boolean = false;\n  private options: ComposerOptions;\n  \n  constructor(editor: Editor, chatInterface: ChatInterface, gemmaService: GemmaService, options?: Partial<ComposerOptions>) {\n    this.editor = editor;\n    this.chatInterface = chatInterface;\n    this.gemmaService = gemmaService;\n    this.options = {\n      showGenerationSteps: true,\n      allowHumanInterruption: true,\n      ...options\n    };\n  }\n  \n  async generateDocument(instruction: string): Promise<void> {\n    this.isGenerating = true;\n    \n    try {\n      // Notify user that generation has started\n      if (this.options.showGenerationSteps) {\n        this.chatInterface.addMessage('assistant', 'Planning document structure...');\n      }\n      \n      // Generate document outline\n      const outline = await this.generateOutline(instruction);\n      \n      if (this.options.showGenerationSteps) {\n        this.chatInterface.addMessage('assistant', `Outline created:\\n${outline}\\n\\nGenerating content...`);\n      }\n      \n      // Generate content for each section\n      for (const section of this.parseOutline(outline)) {\n        await this.generateSection(section);\n        \n        // Check for human interruption if enabled\n        if (this.options.allowHumanInterruption && this.checkForInterruption()) {\n          await this.handleHumanInterruption();\n        }\n      }\n      \n      this.chatInterface.addMessage('assistant', 'Document generation complete! You can now review and edit the document.');\n    } catch (error) {\n      console.error('Error generating document:', error);\n      this.chatInterface.addMessage('assistant', 'Sorry, I encountered an error while generating the document.');\n    } finally {\n      this.isGenerating = false;\n    }\n  }\n  \n  private async generateOutline(instruction: string): Promise<string> {\n    // Generate document outline based on instruction\n  }\n  \n  private parseOutline(outline: string): string[] {\n    // Parse outline into sections\n  }\n  \n  private async generateSection(section: string): Promise<void> {\n    // Generate content for a section and add to editor\n  }\n  \n  private checkForInterruption(): boolean {\n    // Check if user has requested interruption\n  }\n  \n  private async handleHumanInterruption(): Promise<void> {\n    // Handle human feedback and adjust generation\n  }\n  \n  applyFeedback(feedback: string): Promise<void> {\n    // Apply user feedback to the generated document\n  }\n}\n```\n2. Implement real-time progress indicators for generation steps\n3. Create interruption mechanism for human-in-the-loop feedback\n4. Implement feedback processing and document adjustment\n5. Add support for different document types and templates\n6. Create UI for displaying generation progress and accepting feedback",
        "testStrategy": "Test document generation with various instructions and complexity levels. Verify human interruption and feedback mechanisms. Test generation quality and adherence to instructions. Measure generation time and performance. Test error handling and recovery. Conduct user testing to evaluate the composer's usability and output quality.",
        "priority": "high",
        "dependencies": [
          2,
          5,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Human-in-the-Loop Feedback System",
        "description": "Create a system that allows users to provide feedback on AI-generated content and have the AI respond to and incorporate that feedback.",
        "details": "1. Design the feedback system:\n```typescript\ninterface FeedbackRequest {\n  id: string;\n  content: string;\n  context: {\n    documentSection: string;\n    generatedContent: string;\n  };\n  timestamp: Date;\n  status: 'pending' | 'processing' | 'applied' | 'rejected';\n}\n\nclass FeedbackSystem {\n  private documentComposer: DocumentComposer;\n  private gemmaService: GemmaService;\n  private feedbackRequests: FeedbackRequest[] = [];\n  \n  constructor(documentComposer: DocumentComposer, gemmaService: GemmaService) {\n    this.documentComposer = documentComposer;\n    this.gemmaService = gemmaService;\n  }\n  \n  async submitFeedback(content: string, context: FeedbackRequest['context']): Promise<string> {\n    // Create and store feedback request\n    const request: FeedbackRequest = {\n      id: generateId(),\n      content,\n      context,\n      timestamp: new Date(),\n      status: 'pending'\n    };\n    \n    this.feedbackRequests.push(request);\n    \n    // Process feedback\n    return this.processFeedback(request);\n  }\n  \n  private async processFeedback(request: FeedbackRequest): Promise<string> {\n    request.status = 'processing';\n    \n    try {\n      // Analyze feedback using Gemma\n      const analysis = await this.analyzeFeedback(request);\n      \n      // Apply changes based on analysis\n      await this.documentComposer.applyFeedback(analysis);\n      \n      request.status = 'applied';\n      return `Feedback applied: ${analysis.summary}`;\n    } catch (error) {\n      console.error('Error processing feedback:', error);\n      request.status = 'rejected';\n      return 'Sorry, I was unable to apply your feedback. Please try again with more specific instructions.';\n    }\n  }\n  \n  private async analyzeFeedback(request: FeedbackRequest): Promise<any> {\n    // Use Gemma to analyze feedback and determine actions\n    const prompt = `You are helping to improve a document based on user feedback.\\n\\nOriginal content: ${request.context.generatedContent}\\n\\nUser feedback: ${request.content}\\n\\nAnalyze this feedback and provide specific changes to make to the document. Format your response as JSON with 'actions' (what to do) and 'summary' (brief explanation).`;\n    \n    const response = await this.gemmaService.generate(prompt);\n    return JSON.parse(response);\n  }\n}\n```\n2. Implement UI components for submitting and tracking feedback\n3. Create visualization for feedback status and changes\n4. Implement feedback prioritization and queuing\n5. Add support for different types of feedback (style, content, structure)\n6. Create feedback history and undo functionality",
        "testStrategy": "Test feedback processing with various types of feedback. Verify AI response quality and appropriateness. Test feedback application to documents. Measure response time and quality. Test error handling during feedback processing. Conduct user testing to evaluate the feedback loop experience.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement UI Components and Styling",
        "description": "Create the user interface components and styling for the WYSIWYG note application, including the editor, chat interface, and document composer.",
        "details": "1. Design the overall application layout:\n```typescript\nclass AppLayout {\n  private editor: Editor;\n  private chatInterface: ChatInterface;\n  private documentComposer: DocumentComposer;\n  private feedbackSystem: FeedbackSystem;\n  \n  constructor(editor: Editor, chatInterface: ChatInterface, documentComposer: DocumentComposer, feedbackSystem: FeedbackSystem) {\n    this.editor = editor;\n    this.chatInterface = chatInterface;\n    this.documentComposer = documentComposer;\n    this.feedbackSystem = feedbackSystem;\n  }\n  \n  render(): HTMLElement {\n    // Create main application container\n    const container = document.createElement('div');\n    container.className = 'app-container';\n    \n    // Create editor panel\n    const editorPanel = this.createEditorPanel();\n    \n    // Create sidebar with chat and tools\n    const sidebar = this.createSidebar();\n    \n    // Add panels to container\n    container.appendChild(editorPanel);\n    container.appendChild(sidebar);\n    \n    // Add event listeners for panel resizing\n    this.setupResizeHandlers(editorPanel, sidebar);\n    \n    return container;\n  }\n  \n  private createEditorPanel(): HTMLElement {\n    // Create and configure editor panel\n  }\n  \n  private createSidebar(): HTMLElement {\n    // Create sidebar with chat interface and tools\n  }\n  \n  private setupResizeHandlers(editorPanel: HTMLElement, sidebar: HTMLElement): void {\n    // Add resize functionality\n  }\n}\n```\n2. Implement responsive design for different screen sizes\n3. Create CSS styles for all components\n4. Implement dark/light theme support\n5. Create animations for transitions and feedback\n6. Implement accessibility features (ARIA attributes, keyboard navigation)\n7. Create icons and visual elements\n8. Implement UI state management",
        "testStrategy": "Test UI components across different screen sizes and devices. Verify responsive behavior and layout adjustments. Test accessibility using screen readers and keyboard navigation. Verify theme switching and styling consistency. Test animations and transitions for smoothness. Conduct usability testing with different user groups.",
        "priority": "medium",
        "dependencies": [
          2,
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Application State Management",
        "description": "Create a state management system to handle application state, user preferences, and synchronization between components.",
        "details": "1. Design the state management system:\n```typescript\ninterface AppState {\n  editor: {\n    currentNoteId: string | null;\n    unsavedChanges: boolean;\n    selectedBlocks: string[];\n  };\n  notes: {\n    list: NoteMetadata[];\n    lastOpened: string[];\n  };\n  ai: {\n    modelLoaded: boolean;\n    generating: boolean;\n    autoCompletionEnabled: boolean;\n  };\n  ui: {\n    theme: 'light' | 'dark';\n    sidebarOpen: boolean;\n    sidebarWidth: number;\n    activeTab: 'chat' | 'composer' | 'settings';\n  };\n  settings: {\n    autoSave: boolean;\n    autoSaveInterval: number;\n    fontFamily: string;\n    fontSize: number;\n    // Other user preferences\n  };\n}\n\nclass StateManager {\n  private state: AppState;\n  private listeners: Map<string, Set<(state: any) => void>> = new Map();\n  \n  constructor(initialState: Partial<AppState> = {}) {\n    this.state = this.getDefaultState();\n    this.updateState(initialState);\n  }\n  \n  \n  private getDefaultState(): AppState {\n    // Return default application state\n  }\n  \n  getState<K extends keyof AppState>(key: K): AppState[K] {\n    return this.state[key];\n  }\n  \n  updateState(updates: Partial<AppState>): void {\n    // Update state and notify listeners\n    this.state = { ...this.state, ...updates };\n    this.notifyListeners(updates);\n  }\n  \n  subscribe<K extends keyof AppState>(key: K, listener: (state: AppState[K]) => void): () => void {\n    // Add listener for specific state key\n    if (!this.listeners.has(key)) {\n      this.listeners.set(key, new Set());\n    }\n    \n    this.listeners.get(key)!.add(listener);\n    \n    // Return unsubscribe function\n    return () => {\n      const listeners = this.listeners.get(key);\n      if (listeners) {\n        listeners.delete(listener);\n      }\n    };\n  }\n  \n  private notifyListeners(updates: Partial<AppState>): void {\n    // Notify relevant listeners of state changes\n    Object.keys(updates).forEach(key => {\n      const listeners = this.listeners.get(key as keyof AppState);\n      if (listeners) {\n        const value = this.state[key as keyof AppState];\n        listeners.forEach(listener => listener(value));\n      }\n    });\n  }\n  \n  saveToLocalStorage(): void {\n    // Save state to localStorage for persistence\n  }\n  \n  loadFromLocalStorage(): void {\n    // Load state from localStorage\n  }\n}\n```\n2. Implement state persistence using localStorage\n3. Create actions and reducers for state updates\n4. Implement state synchronization between components\n5. Add state change logging for debugging\n6. Create utility functions for common state operations\n7. Implement state migration for version updates",
        "testStrategy": "Test state updates and listener notifications. Verify state persistence across page reloads. Test state synchronization between components. Measure performance impact of state operations. Test state migrations with different versions. Create mock state for component testing.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          5,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Application Integration and Testing",
        "description": "Integrate all components of the application and implement comprehensive testing to ensure functionality and reliability.",
        "details": "1. Create the main application class:\n```typescript\nclass WYSIWYGNoteApp {\n  private stateManager: StateManager;\n  private editor: Editor;\n  private fileStorage: FileStorageService;\n  private autoSave: AutoSaveService;\n  private gemmaService: GemmaService;\n  private autoCompletion: AutoCompletionService;\n  private chatInterface: ChatInterface;\n  private documentComposer: DocumentComposer;\n  private feedbackSystem: FeedbackSystem;\n  private appLayout: AppLayout;\n  \n  constructor() {\n    // Initialize state manager\n    this.stateManager = new StateManager();\n    this.stateManager.loadFromLocalStorage();\n    \n    // Initialize components\n    this.editor = new Editor();\n    this.fileStorage = new FileStorageService();\n    this.autoSave = new AutoSaveService(this.editor, this.fileStorage);\n    this.gemmaService = new GemmaService();\n    this.autoCompletion = new AutoCompletionService(this.editor, this.gemmaService);\n    this.chatInterface = new ChatInterface(this.gemmaService);\n    this.documentComposer = new DocumentComposer(this.editor, this.chatInterface, this.gemmaService);\n    this.feedbackSystem = new FeedbackSystem(this.documentComposer, this.gemmaService);\n    this.appLayout = new AppLayout(this.editor, this.chatInterface, this.documentComposer, this.feedbackSystem);\n    \n    // Setup event listeners and state subscriptions\n    this.setupEventListeners();\n    this.setupStateSubscriptions();\n  }\n  \n  async initialize(): Promise<void> {\n    try {\n      // Initialize Gemma model\n      await this.gemmaService.initialize();\n      this.stateManager.updateState({ ai: { modelLoaded: true } });\n      \n      // Load notes list\n      const notes = await this.fileStorage.listNotes();\n      this.stateManager.updateState({ notes: { list: notes } });\n      \n      // Start auto-save\n      if (this.stateManager.getState('settings').autoSave) {\n        this.autoSave.start();\n      }\n      \n      // Enable auto-completion if enabled in settings\n      if (this.stateManager.getState('ai').autoCompletionEnabled) {\n        this.autoCompletion.enable();\n      }\n      \n      // Render application\n      document.body.appendChild(this.appLayout.render());\n    } catch (error) {\n      console.error('Error initializing application:', error);\n      // Show error message to user\n    }\n  }\n  \n  private setupEventListeners(): void {\n    // Setup global event listeners\n  }\n  \n  private setupStateSubscriptions(): void {\n    // Subscribe to state changes\n  }\n}\n```\n2. Implement integration tests for component interactions\n3. Create end-to-end tests for user workflows\n4. Implement performance testing and optimization\n5. Create test fixtures and mocks for testing\n6. Implement error boundary and global error handling\n7. Add telemetry and usage analytics (optional)\n8. Create documentation for codebase and architecture",
        "testStrategy": "Implement comprehensive test suite including unit tests, integration tests, and end-to-end tests. Test all user workflows and features. Measure performance metrics and optimize as needed. Test error handling and recovery. Conduct user acceptance testing. Verify compatibility across different environments and browsers.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Playwright End-to-End Testing Suite",
        "description": "Create comprehensive Playwright end-to-end tests for the WYSIWYG note application, covering all major features and user flows.",
        "details": "1. Install Playwright and configure the testing environment:\n```bash\nnpm install --save-dev @playwright/test\nnpx playwright install\n```\n\n2. Create a Playwright configuration file (playwright.config.ts):\n```typescript\nimport { PlaywrightTestConfig } from '@playwright/test';\n\nconst config: PlaywrightTestConfig = {\n  testDir: './tests/e2e',\n  timeout: 30000,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: [['html'], ['list']],\n  use: {\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'on-first-retry',\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { browserName: 'chromium' },\n    },\n    {\n      name: 'firefox',\n      use: { browserName: 'firefox' },\n    },\n    {\n      name: 'webkit',\n      use: { browserName: 'webkit' },\n    },\n  ],\n};\n\nexport default config;\n```\n\n3. Create test fixtures for common setup operations:\n```typescript\nimport { test as base } from '@playwright/test';\n\ntype AppFixtures = {\n  loggedInPage: Page;\n  createNewNote: () => Promise<void>;\n};\n\nexport const test = base.extend<AppFixtures>({\n  loggedInPage: async ({ page }, use) => {\n    // Setup application state\n    await page.goto('/');\n    // Any login or initialization needed\n    await use(page);\n  },\n  createNewNote: async ({ page }, use) => {\n    const createNote = async () => {\n      await page.click('[data-testid=\"new-note-button\"]');\n      await page.waitForSelector('[data-testid=\"editor-container\"]');\n    };\n    await use(createNote);\n  },\n});\n\nexport { expect } from '@playwright/test';\n```\n\n4. Implement test suites for each major feature:\n\na. Block-based editor tests:\n```typescript\nimport { test, expect } from './fixtures';\n\ntest.describe('Block-based Editor', () => {\n  test('should create different block types', async ({ loggedInPage, createNewNote }) => {\n    await createNewNote();\n    \n    // Test paragraph block\n    await loggedInPage.fill('[data-testid=\"editor-block\"]', 'This is a paragraph');\n    await loggedInPage.press('[data-testid=\"editor-block\"]', 'Enter');\n    \n    // Test heading block\n    await loggedInPage.keyboard.type('/heading');\n    await loggedInPage.keyboard.press('Enter');\n    await loggedInPage.keyboard.type('This is a heading');\n    \n    // Verify blocks were created correctly\n    const paragraphBlock = await loggedInPage.locator('[data-block-type=\"paragraph\"]').first();\n    await expect(paragraphBlock).toContainText('This is a paragraph');\n    \n    const headingBlock = await loggedInPage.locator('[data-block-type=\"heading\"]').first();\n    await expect(headingBlock).toContainText('This is a heading');\n  });\n  \n  test('should allow block reordering', async ({ loggedInPage, createNewNote }) => {\n    await createNewNote();\n    \n    // Create multiple blocks\n    await loggedInPage.fill('[data-testid=\"editor-block\"]', 'Block 1');\n    await loggedInPage.press('[data-testid=\"editor-block\"]', 'Enter');\n    await loggedInPage.keyboard.type('Block 2');\n    \n    // Test drag and drop functionality\n    const block1 = await loggedInPage.locator('text=Block 1');\n    const block2 = await loggedInPage.locator('text=Block 2');\n    \n    // Get initial positions\n    const block1InitialPosition = await block1.boundingBox();\n    const block2InitialPosition = await block2.boundingBox();\n    \n    // Perform drag and drop\n    await loggedInPage.dragAndDrop(\n      '[data-testid=\"block-drag-handle\"]:first-of-type',\n      '[data-testid=\"editor-container\"]',\n      { targetPosition: { x: 10, y: block2InitialPosition.y + 10 } }\n    );\n    \n    // Verify new order\n    const blocks = await loggedInPage.locator('[data-testid=\"editor-block\"]').all();\n    await expect(blocks[0]).toContainText('Block 2');\n    await expect(blocks[1]).toContainText('Block 1');\n  });\n});\n```\n\nb. Auto-save functionality tests:\n```typescript\nimport { test, expect } from './fixtures';\n\ntest.describe('Auto-save Functionality', () => {\n  test('should auto-save content after typing', async ({ loggedInPage, createNewNote }) => {\n    await createNewNote();\n    \n    // Type content\n    await loggedInPage.fill('[data-testid=\"editor-block\"]', 'Content that should be auto-saved');\n    \n    // Wait for auto-save to trigger (based on the interval set in the implementation)\n    await loggedInPage.waitForSelector('[data-testid=\"save-status-saved\"]', { timeout: 10000 });\n    \n    // Reload the page to verify content persistence\n    await loggedInPage.reload();\n    \n    // Verify content was saved\n    await expect(loggedInPage.locator('[data-testid=\"editor-block\"]')).toContainText('Content that should be auto-saved');\n  });\n  \n  test('should recover content after browser crash', async ({ loggedInPage, createNewNote, context }) => {\n    await createNewNote();\n    \n    // Type content\n    await loggedInPage.fill('[data-testid=\"editor-block\"]', 'Content for crash recovery test');\n    \n    // Wait for auto-save\n    await loggedInPage.waitForSelector('[data-testid=\"save-status-saved\"]', { timeout: 10000 });\n    \n    // Simulate browser crash by closing without proper exit\n    await context.close();\n    \n    // Create new context and page\n    const newContext = await browser.newContext();\n    const newPage = await newContext.newPage();\n    \n    // Navigate to the app\n    await newPage.goto('/');\n    \n    // Check for recovery dialog and confirm\n    await newPage.click('[data-testid=\"recover-session-button\"]');\n    \n    // Verify content was recovered\n    await expect(newPage.locator('[data-testid=\"editor-block\"]')).toContainText('Content for crash recovery test');\n    \n    await newContext.close();\n  });\n});\n```\n\nc. AI chat interface tests:\n```typescript\nimport { test, expect } from './fixtures';\n\ntest.describe('AI Chat Interface', () => {\n  test('should send messages and receive responses', async ({ loggedInPage }) => {\n    // Navigate to chat interface\n    await loggedInPage.click('[data-testid=\"chat-tab\"]');\n    \n    // Type and send a message\n    await loggedInPage.fill('[data-testid=\"chat-input\"]', 'Hello, can you help me write a document?');\n    await loggedInPage.click('[data-testid=\"send-message-button\"]');\n    \n    // Verify user message appears in chat\n    await expect(loggedInPage.locator('[data-testid=\"user-message\"]').last()).toContainText('Hello, can you help me write a document?');\n    \n    // Wait for AI response\n    await loggedInPage.waitForSelector('[data-testid=\"ai-message\"]', { timeout: 30000 });\n    \n    // Verify AI responded\n    const aiMessage = await loggedInPage.locator('[data-testid=\"ai-message\"]').last();\n    await expect(aiMessage).toBeVisible();\n    await expect(aiMessage).not.toBeEmpty();\n  });\n  \n  test('should handle markdown rendering in chat', async ({ loggedInPage }) => {\n    // Navigate to chat interface\n    await loggedInPage.click('[data-testid=\"chat-tab\"]');\n    \n    // Send a message that should trigger markdown response\n    await loggedInPage.fill('[data-testid=\"chat-input\"]', 'Show me how to format markdown');\n    await loggedInPage.click('[data-testid=\"send-message-button\"]');\n    \n    // Wait for AI response\n    await loggedInPage.waitForSelector('[data-testid=\"ai-message\"]', { timeout: 30000 });\n    \n    // Verify markdown elements are rendered correctly\n    const aiMessage = await loggedInPage.locator('[data-testid=\"ai-message\"]').last();\n    await expect(aiMessage.locator('h1, h2, h3, code, pre, ul, ol')).toBeVisible();\n  });\n});\n```\n\nd. Document composer tests:\n```typescript\nimport { test, expect } from './fixtures';\n\ntest.describe('Document Composer', () => {\n  test('should generate document based on user instructions', async ({ loggedInPage }) => {\n    // Navigate to document composer\n    await loggedInPage.click('[data-testid=\"composer-tab\"]');\n    \n    // Enter document generation prompt\n    await loggedInPage.fill('[data-testid=\"composer-prompt\"]', 'Create a short document about renewable energy');\n    await loggedInPage.click('[data-testid=\"generate-document-button\"]');\n    \n    // Wait for generation to complete\n    await loggedInPage.waitForSelector('[data-testid=\"generation-complete\"]', { timeout: 60000 });\n    \n    // Verify document was generated\n    const documentBlocks = await loggedInPage.locator('[data-testid=\"composer-document-block\"]').all();\n    expect(documentBlocks.length).toBeGreaterThan(0);\n    \n    // Verify document content is relevant to the prompt\n    const documentText = await loggedInPage.locator('[data-testid=\"composer-document\"]').innerText();\n    expect(documentText.toLowerCase()).toContain('renewable');\n    expect(documentText.toLowerCase()).toContain('energy');\n  });\n  \n  test('should allow human-in-the-loop editing during generation', async ({ loggedInPage }) => {\n    // Navigate to document composer\n    await loggedInPage.click('[data-testid=\"composer-tab\"]');\n    \n    // Enable step-by-step generation\n    await loggedInPage.click('[data-testid=\"step-by-step-toggle\"]');\n    \n    // Enter document generation prompt\n    await loggedInPage.fill('[data-testid=\"composer-prompt\"]', 'Create a business proposal outline');\n    await loggedInPage.click('[data-testid=\"generate-document-button\"]');\n    \n    // Wait for first generation step\n    await loggedInPage.waitForSelector('[data-testid=\"generation-step-complete\"]', { timeout: 30000 });\n    \n    // Provide feedback on the first step\n    await loggedInPage.fill('[data-testid=\"step-feedback\"]', 'Make it more focused on sustainability');\n    await loggedInPage.click('[data-testid=\"submit-feedback-button\"]');\n    \n    // Continue generation\n    await loggedInPage.click('[data-testid=\"continue-generation-button\"]');\n    \n    // Wait for generation to complete\n    await loggedInPage.waitForSelector('[data-testid=\"generation-complete\"]', { timeout: 60000 });\n    \n    // Verify feedback was incorporated\n    const documentText = await loggedInPage.locator('[data-testid=\"composer-document\"]').innerText();\n    expect(documentText.toLowerCase()).toContain('sustainability');\n  });\n});\n```\n\ne. Human-in-the-loop feedback system tests:\n```typescript\nimport { test, expect } from './fixtures';\n\ntest.describe('Human-in-the-Loop Feedback System', () => {\n  test('should process and apply feedback to generated content', async ({ loggedInPage }) => {\n    // Navigate to document composer\n    await loggedInPage.click('[data-testid=\"composer-tab\"]');\n    \n    // Generate a document\n    await loggedInPage.fill('[data-testid=\"composer-prompt\"]', 'Write a short story about space exploration');\n    await loggedInPage.click('[data-testid=\"generate-document-button\"]');\n    \n    // Wait for generation to complete\n    await loggedInPage.waitForSelector('[data-testid=\"generation-complete\"]', { timeout: 60000 });\n    \n    // Select a section and provide feedback\n    await loggedInPage.click('[data-testid=\"composer-document-block\"]:first-child');\n    await loggedInPage.click('[data-testid=\"provide-feedback-button\"]');\n    \n    // Enter feedback\n    await loggedInPage.fill('[data-testid=\"feedback-input\"]', 'Make this section more futuristic and include mention of quantum technology');\n    await loggedInPage.click('[data-testid=\"submit-feedback-button\"]');\n    \n    // Wait for feedback processing\n    await loggedInPage.waitForSelector('[data-testid=\"feedback-applied\"]', { timeout: 30000 });\n    \n    // Verify feedback was applied\n    const updatedSection = await loggedInPage.locator('[data-testid=\"composer-document-block\"]:first-child').innerText();\n    expect(updatedSection.toLowerCase()).toContain('quantum');\n    expect(updatedSection.toLowerCase()).toContain('futuristic');\n  });\n});\n```\n\n5. Create integration tests for full application workflows:\n```typescript\nimport { test, expect } from './fixtures';\n\ntest.describe('Full Application Workflow', () => {\n  test('should support complete note creation and editing workflow', async ({ loggedInPage }) => {\n    // Create a new note\n    await loggedInPage.click('[data-testid=\"new-note-button\"]');\n    \n    // Add title\n    await loggedInPage.fill('[data-testid=\"note-title\"]', 'Comprehensive Test Note');\n    \n    // Add content blocks\n    await loggedInPage.fill('[data-testid=\"editor-block\"]', 'This is the first paragraph');\n    await loggedInPage.press('[data-testid=\"editor-block\"]', 'Enter');\n    \n    // Create a heading\n    await loggedInPage.keyboard.type('/heading');\n    await loggedInPage.keyboard.press('Enter');\n    await loggedInPage.keyboard.type('Important Section');\n    await loggedInPage.keyboard.press('Enter');\n    \n    // Add more content\n    await loggedInPage.keyboard.type('Content under the heading');\n    \n    // Wait for auto-save\n    await loggedInPage.waitForSelector('[data-testid=\"save-status-saved\"]', { timeout: 10000 });\n    \n    // Switch to AI chat\n    await loggedInPage.click('[data-testid=\"chat-tab\"]');\n    \n    // Ask AI for suggestions\n    await loggedInPage.fill('[data-testid=\"chat-input\"]', 'Suggest improvements for my note about Important Section');\n    await loggedInPage.click('[data-testid=\"send-message-button\"]');\n    \n    // Wait for AI response\n    await loggedInPage.waitForSelector('[data-testid=\"ai-message\"]', { timeout: 30000 });\n    \n    // Apply AI suggestion\n    await loggedInPage.click('[data-testid=\"apply-suggestion-button\"]');\n    \n    // Switch back to editor\n    await loggedInPage.click('[data-testid=\"editor-tab\"]');\n    \n    // Verify suggestion was applied\n    const editorContent = await loggedInPage.locator('[data-testid=\"editor-container\"]').innerText();\n    expect(editorContent).toContain('Important Section');\n    \n    // Verify note was saved\n    await loggedInPage.reload();\n    await expect(loggedInPage.locator('[data-testid=\"note-title\"]')).toHaveValue('Comprehensive Test Note');\n  });\n});\n```\n\n6. Add CI/CD integration for Playwright tests:\n```yaml\n# .github/workflows/e2e-tests.yml\nname: E2E Tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    timeout-minutes: 60\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-node@v3\n      with:\n        node-version: 16\n    - name: Install dependencies\n      run: npm ci\n    - name: Install Playwright Browsers\n      run: npx playwright install --with-deps\n    - name: Build application\n      run: npm run build\n    - name: Serve application\n      run: npm run serve &\n    - name: Run Playwright tests\n      run: npx playwright test\n    - uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: playwright-report\n        path: playwright-report/\n        retention-days: 30\n```\n\n7. Create test utilities for common testing patterns:\n```typescript\n// tests/e2e/utils/test-helpers.ts\nimport { Page } from '@playwright/test';\n\nexport async function createNoteWithBlocks(page: Page, title: string, blocks: Array<{type: string, content: string}>) {\n  await page.click('[data-testid=\"new-note-button\"]');\n  await page.fill('[data-testid=\"note-title\"]', title);\n  \n  for (const block of blocks) {\n    if (block.type !== 'paragraph') {\n      await page.keyboard.type(`/${block.type}`);\n      await page.keyboard.press('Enter');\n    }\n    \n    await page.keyboard.type(block.content);\n    await page.keyboard.press('Enter');\n  }\n  \n  // Wait for auto-save\n  await page.waitForSelector('[data-testid=\"save-status-saved\"]', { timeout: 10000 });\n}\n\nexport async function waitForAIProcessing(page: Page) {\n  await page.waitForSelector('[data-testid=\"ai-processing\"]', { state: 'visible', timeout: 5000 }).catch(() => {\n    // If AI processing indicator doesn't appear, it might have been too fast\n    console.log('AI processing indicator not found, continuing...');\n  });\n  \n  // Wait for processing to complete\n  await page.waitForSelector('[data-testid=\"ai-processing\"]', { state: 'hidden', timeout: 60000 }).catch(() => {\n    console.log('AI processing indicator did not disappear, might be an issue');\n  });\n}\n```",
        "testStrategy": "1. **Unit Test Coverage Verification**:\n   - Use Jest coverage reports to identify components that lack sufficient test coverage\n   - Ensure all critical paths in the application have corresponding Playwright tests\n   - Create a test coverage matrix mapping features to test cases\n\n2. **Test Environment Setup**:\n   - Configure a dedicated test environment with controlled data\n   - Set up test fixtures for common scenarios to avoid repetitive setup code\n   - Create mock implementations of the Gemma SLM model for predictable AI responses\n\n3. **Cross-Browser Testing**:\n   - Run tests on Chromium, Firefox, and WebKit to ensure cross-browser compatibility\n   - Verify responsive design by testing at multiple viewport sizes\n   - Test with different operating systems (Windows, macOS, Linux)\n\n4. **Performance Testing**:\n   - Measure page load times and time-to-interactive metrics\n   - Test editor performance with large documents (1000+ blocks)\n   - Verify AI response times remain acceptable under load\n\n5. **Accessibility Testing**:\n   - Use Playwright's accessibility testing capabilities to verify WCAG compliance\n   - Test keyboard navigation throughout the application\n   - Verify screen reader compatibility for all interactive elements\n\n6. **Error Handling and Recovery**:\n   - Simulate network failures during auto-save operations\n   - Test application behavior during AI model loading failures\n   - Verify error messages are displayed appropriately to users\n\n7. **Visual Regression Testing**:\n   - Implement screenshot comparison tests for critical UI components\n   - Verify UI consistency across different themes and configurations\n   - Test animations and transitions for smoothness\n\n8. **End-to-End Workflow Testing**:\n   - Create comprehensive tests for complete user journeys\n   - Test integration between different features (editor  chat  composer)\n   - Verify data persistence across page reloads and browser sessions\n\n9. **Continuous Integration**:\n   - Configure GitHub Actions to run Playwright tests on every pull request\n   - Set up automatic test reports and failure notifications\n   - Implement test retries for flaky tests to reduce false negatives\n\n10. **Manual Verification**:\n    - Create a test plan for features that are difficult to automate\n    - Conduct exploratory testing sessions after major changes\n    - Verify subjective aspects like AI response quality and user experience",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Integrate AI Content Generation Directly into Editor",
        "description": "Modify the AI content generation system to write directly into the editor area instead of only displaying in the chat UI, ensuring generated content appears as blocks in the main editor where the user is working.",
        "details": "1. Update the integration between the AI services and the editor component:\n```typescript\nclass ContentGenerationService {\n  private editor: Editor;\n  private gemmaService: GemmaService;\n  private chatInterface: ChatInterface;\n  \n  constructor(editor: Editor, gemmaService: GemmaService, chatInterface: ChatInterface) {\n    this.editor = editor;\n    this.gemmaService = gemmaService;\n    this.chatInterface = chatInterface;\n  }\n  \n  async generateContent(prompt: string, insertionPoint: string | null = null): Promise<void> {\n    // Show loading indicator in the editor\n    this.editor.showLoadingIndicator(insertionPoint);\n    \n    try {\n      // Generate content using AI\n      const generatedContent = await this.gemmaService.generateContent(prompt);\n      \n      // Parse the generated content into appropriate block types\n      const blocks = this.parseContentIntoBlocks(generatedContent);\n      \n      // Insert the blocks into the editor at the current cursor position or specified insertion point\n      this.editor.insertBlocks(blocks, insertionPoint);\n      \n      // Also display the generated content in chat for reference (optional)\n      this.chatInterface.addMessage({\n        role: 'assistant',\n        content: generatedContent,\n        metadata: { insertedInEditor: true }\n      });\n    } catch (error) {\n      this.handleGenerationError(error);\n    } finally {\n      this.editor.hideLoadingIndicator();\n    }\n  }\n  \n  private parseContentIntoBlocks(content: string): Block[] {\n    // Logic to parse generated content into appropriate block types\n    // This should handle paragraphs, headings, lists, code blocks, etc.\n    const blocks: Block[] = [];\n    \n    // Simple example implementation:\n    const paragraphs = content.split('\\n\\n');\n    for (const paragraph of paragraphs) {\n      if (paragraph.trim().startsWith('# ')) {\n        blocks.push({\n          id: generateUniqueId(),\n          type: 'heading',\n          content: paragraph.replace(/^# /, ''),\n          level: 1\n        });\n      } else if (paragraph.trim().startsWith('```')) {\n        // Handle code blocks\n        const codeContent = paragraph.replace(/^```\\w*\\n/, '').replace(/```$/, '');\n        blocks.push({\n          id: generateUniqueId(),\n          type: 'code',\n          content: codeContent\n        });\n      } else {\n        blocks.push({\n          id: generateUniqueId(),\n          type: 'paragraph',\n          content: paragraph\n        });\n      }\n    }\n    \n    return blocks;\n  }\n  \n  private handleGenerationError(error: any): void {\n    console.error('Content generation error:', error);\n    this.editor.showErrorNotification('Failed to generate content. Please try again.');\n    this.chatInterface.addMessage({\n      role: 'system',\n      content: 'Sorry, I encountered an error while generating content.'\n    });\n  }\n}\n```\n\n2. Update the AutoCompletionService to insert completions directly into the editor:\n```typescript\nclass AutoCompletionService {\n  private editor: Editor;\n  private gemmaService: GemmaService;\n  private contentGenerationService: ContentGenerationService;\n  \n  constructor(editor: Editor, gemmaService: GemmaService, contentGenerationService: ContentGenerationService) {\n    this.editor = editor;\n    this.gemmaService = gemmaService;\n    this.contentGenerationService = contentGenerationService;\n  }\n  \n  async suggestCompletion(blockId: string, currentContent: string): Promise<void> {\n    // Get completion suggestion from AI\n    const completion = await this.gemmaService.getCompletion(currentContent);\n    \n    // Insert the completion directly into the editor\n    this.editor.appendToBlock(blockId, completion);\n  }\n}\n```\n\n3. Update the DocumentComposer to insert generated documents into the editor:\n```typescript\nclass DocumentComposer {\n  private editor: Editor;\n  private gemmaService: GemmaService;\n  private contentGenerationService: ContentGenerationService;\n  \n  constructor(editor: Editor, gemmaService: GemmaService, contentGenerationService: ContentGenerationService) {\n    this.editor = editor;\n    this.gemmaService = gemmaService;\n    this.contentGenerationService = contentGenerationService;\n  }\n  \n  async composeDocument(topic: string, outline: string[]): Promise<void> {\n    // Generate document content\n    const documentContent = await this.gemmaService.composeDocument(topic, outline);\n    \n    // Use the content generation service to insert the document into the editor\n    await this.contentGenerationService.generateContent(documentContent);\n  }\n}\n```\n\n4. Modify the ChatInterface to distinguish between conversation messages and content generation:\n```typescript\ninterface ChatMessage {\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  metadata?: {\n    insertedInEditor?: boolean;\n    relatedBlockIds?: string[];\n  };\n}\n\nclass ChatInterface {\n  private messages: ChatMessage[] = [];\n  private contentGenerationService: ContentGenerationService;\n  \n  constructor(contentGenerationService: ContentGenerationService) {\n    this.contentGenerationService = contentGenerationService;\n  }\n  \n  addMessage(message: ChatMessage): void {\n    this.messages.push(message);\n    this.renderMessages();\n  }\n  \n  async handleUserMessage(content: string): Promise<void> {\n    // Add user message to chat\n    this.addMessage({\n      role: 'user',\n      content\n    });\n    \n    // Determine if this is a content generation request\n    if (this.isContentGenerationRequest(content)) {\n      // Generate content and insert into editor\n      await this.contentGenerationService.generateContent(content);\n    } else {\n      // Regular conversation - just respond in chat\n      const response = await this.getAIResponse(content);\n      this.addMessage({\n        role: 'assistant',\n        content: response\n      });\n    }\n  }\n  \n  private isContentGenerationRequest(content: string): boolean {\n    // Logic to determine if the message is requesting content generation\n    return content.toLowerCase().includes('write') || \n           content.toLowerCase().includes('generate') ||\n           content.toLowerCase().includes('create');\n  }\n  \n  private renderMessages(): void {\n    // Logic to render messages in the chat UI\n    // For messages that were inserted in the editor, add a visual indicator\n  }\n}\n```\n\n5. Update the application integration to connect these components:\n```typescript\nclass WYSIWYGNoteApp {\n  // ... existing properties\n  \n  private initializeContentGeneration(): void {\n    // Create the content generation service\n    const contentGenerationService = new ContentGenerationService(\n      this.editor,\n      this.gemmaService,\n      this.chatInterface\n    );\n    \n    // Update the auto-completion service\n    this.autoCompletion = new AutoCompletionService(\n      this.editor,\n      this.gemmaService,\n      contentGenerationService\n    );\n    \n    // Update the document composer\n    this.documentComposer = new DocumentComposer(\n      this.editor,\n      this.gemmaService,\n      contentGenerationService\n    );\n    \n    // Update the chat interface\n    this.chatInterface = new ChatInterface(contentGenerationService);\n    \n    // Add event listeners for editor interactions that might trigger AI assistance\n    this.editor.on('blockSelected', this.handleBlockSelected.bind(this));\n    this.editor.on('contentChanged', this.handleContentChanged.bind(this));\n  }\n}\n```\n\n6. Add UI indicators to show when content is being generated and where it will be inserted:\n   - Add a subtle highlight or cursor animation at the insertion point\n   - Show a loading indicator while content is being generated\n   - Provide visual feedback when content has been inserted\n\n7. Implement keyboard shortcuts and UI controls for triggering content generation directly in the editor:\n   - Add a \"Generate here\" context menu option\n   - Implement a keyboard shortcut (e.g., Alt+G) to trigger generation at cursor position\n   - Add toolbar buttons for common generation tasks",
        "testStrategy": "1. **Unit Testing**:\n   - Test the ContentGenerationService's parseContentIntoBlocks method with various input formats\n   - Verify that generated blocks have the correct structure and content\n   - Test error handling in the content generation process\n   - Verify that the AutoCompletionService correctly appends completions to blocks\n\n2. **Integration Testing**:\n   - Test the integration between the AI services and the editor\n   - Verify that generated content is correctly inserted at the specified position\n   - Test the flow from user request in chat to content appearing in the editor\n   - Verify that the chat interface correctly identifies content generation requests\n   - Test that content generation works with all supported block types\n\n3. **End-to-End Testing**:\n   - Create Playwright tests that simulate user interactions:\n     ```typescript\n     test('AI content is inserted into editor when requested', async ({ page }) => {\n       await page.goto('/app');\n       await page.click('.editor-container');\n       await page.type('.editor-block', 'This is my document start');\n       \n       // Open chat and request content generation\n       await page.click('.chat-button');\n       await page.type('.chat-input', 'Generate a paragraph about climate change');\n       await page.click('.chat-send-button');\n       \n       // Wait for content to be generated and inserted\n       await page.waitForSelector('.editor-block:nth-child(2)');\n       \n       // Verify content was inserted in editor\n       const blocks = await page.$$('.editor-block');\n       expect(blocks.length).toBeGreaterThan(1);\n       \n       // Verify the content is about climate change\n       const secondBlockText = await blocks[1].textContent();\n       expect(secondBlockText).toContain('climate');\n     });\n     ```\n   - Test auto-completion functionality\n   - Test document composition\n   - Test keyboard shortcuts and UI controls for content generation\n\n4. **User Experience Testing**:\n   - Conduct usability testing to ensure the content generation flow is intuitive\n   - Verify that loading indicators provide appropriate feedback\n   - Test that the UI clearly distinguishes between chat conversation and content generation\n   - Verify that users can easily understand where generated content will be inserted\n\n5. **Performance Testing**:\n   - Measure the time taken to generate and insert content\n   - Test with large documents to ensure performance remains acceptable\n   - Verify that the UI remains responsive during content generation\n\n6. **Regression Testing**:\n   - Verify that existing editor functionality continues to work correctly\n   - Test that chat functionality for conversation (not content generation) still works as expected\n   - Ensure that the feedback system still works with the new content generation flow",
        "status": "done",
        "dependencies": [
          2,
          7,
          8,
          10,
          11,
          12
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement GitHub Copilot-Style Auto-Completion Feature",
        "description": "Enhance the auto-completion feature to provide GitHub Copilot-style inline suggestions that appear as ghost text after the cursor, which users can accept with Tab or dismiss with Escape or by continuing to type.",
        "details": "1. Extend the existing AutoCompletionService to support inline ghost text suggestions:\n```typescript\nclass AutoCompletionService {\n  private editor: Editor;\n  private gemmaService: GemmaService;\n  private isEnabled: boolean = true;\n  private currentSuggestion: string | null = null;\n  private suggestionElement: HTMLElement | null = null;\n  \n  constructor(editor: Editor, gemmaService: GemmaService) {\n    this.editor = editor;\n    this.gemmaService = gemmaService;\n  }\n  \n  enable(): void {\n    this.isEnabled = true;\n    this.attachListeners();\n  }\n  \n  disable(): void {\n    this.isEnabled = false;\n    this.detachListeners();\n    this.clearCurrentSuggestion();\n  }\n  \n  private attachListeners(): void {\n    this.editor.on('change', this.handleEditorChange.bind(this));\n    this.editor.on('keydown', this.handleKeyDown.bind(this));\n    this.editor.on('cursorMove', this.handleCursorMove.bind(this));\n  }\n  \n  private detachListeners(): void {\n    this.editor.off('change', this.handleEditorChange.bind(this));\n    this.editor.off('keydown', this.handleKeyDown.bind(this));\n    this.editor.off('cursorMove', this.handleCursorMove.bind(this));\n  }\n  \n  private async handleEditorChange(event: EditorChangeEvent): Promise<void> {\n    if (!this.isEnabled) return;\n    \n    // Clear any existing suggestion when user types\n    this.clearCurrentSuggestion();\n    \n    // Debounce to avoid excessive API calls\n    this.debouncedGetSuggestion();\n  }\n  \n  private debouncedGetSuggestion = debounce(async () => {\n    const context = this.editor.getContextAroundCursor(500); // Get 500 chars around cursor\n    const cursorPosition = this.editor.getCursorPosition();\n    \n    try {\n      const suggestion = await this.gemmaService.getSuggestion(context, cursorPosition);\n      if (suggestion && suggestion.length > 0) {\n        this.showSuggestion(suggestion);\n      }\n    } catch (error) {\n      console.error('Error getting suggestion:', error);\n    }\n  }, 300);\n  \n  private showSuggestion(suggestion: string): void {\n    this.currentSuggestion = suggestion;\n    \n    // Create or update ghost text element\n    if (!this.suggestionElement) {\n      this.suggestionElement = document.createElement('span');\n      this.suggestionElement.className = 'ghost-suggestion';\n      // Apply styling for ghost text (gray, slightly transparent)\n      this.suggestionElement.style.color = 'rgba(128, 128, 128, 0.8)';\n      this.suggestionElement.style.position = 'absolute';\n      this.suggestionElement.style.pointerEvents = 'none'; // Don't interfere with editor interactions\n    }\n    \n    this.suggestionElement.textContent = suggestion;\n    \n    // Position the ghost text after the cursor\n    const cursorCoords = this.editor.getCursorCoordinates();\n    this.suggestionElement.style.left = `${cursorCoords.x}px`;\n    this.suggestionElement.style.top = `${cursorCoords.y}px`;\n    \n    // Add to editor container\n    this.editor.getContainer().appendChild(this.suggestionElement);\n  }\n  \n  private clearCurrentSuggestion(): void {\n    this.currentSuggestion = null;\n    if (this.suggestionElement) {\n      this.suggestionElement.remove();\n      this.suggestionElement = null;\n    }\n  }\n  \n  private handleKeyDown(event: KeyboardEvent): void {\n    if (!this.currentSuggestion) return;\n    \n    if (event.key === 'Tab') {\n      // Accept suggestion\n      event.preventDefault();\n      this.acceptSuggestion();\n    } else if (event.key === 'Escape') {\n      // Dismiss suggestion\n      event.preventDefault();\n      this.clearCurrentSuggestion();\n    } else if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight' && \n               event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n      // Dismiss suggestion on any typing (except arrow keys)\n      this.clearCurrentSuggestion();\n    }\n  }\n  \n  private handleCursorMove(): void {\n    // Clear suggestion when cursor moves\n    this.clearCurrentSuggestion();\n  }\n  \n  private acceptSuggestion(): void {\n    if (!this.currentSuggestion) return;\n    \n    // Insert the suggestion at current cursor position\n    this.editor.insertTextAtCursor(this.currentSuggestion);\n    \n    // Clear the suggestion after accepting\n    this.clearCurrentSuggestion();\n  }\n}\n\n// Helper function for debouncing\nfunction debounce(func: Function, wait: number): (...args: any[]) => void {\n  let timeout: NodeJS.Timeout | null = null;\n  return function(...args: any[]): void {\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n```\n\n2. Modify the GemmaService to provide context-aware suggestions:\n```typescript\nclass GemmaService {\n  // ... existing code ...\n  \n  async getSuggestion(context: string, cursorPosition: CursorPosition): Promise<string> {\n    const prompt = `\n      You are an intelligent code and text completion assistant.\n      Based on the following context, provide a brief, relevant continuation that would be helpful to the user.\n      Only provide the continuation text, not any explanation.\n      \n      Context before cursor:\n      ${context.substring(0, cursorPosition.offset)}\n      \n      Context after cursor:\n      ${context.substring(cursorPosition.offset)}\n    `;\n    \n    try {\n      const response = await this.model.generateText(prompt, {\n        maxOutputTokens: 50,\n        temperature: 0.2, // Lower temperature for more predictable completions\n      });\n      \n      return response.trim();\n    } catch (error) {\n      console.error('Error generating suggestion:', error);\n      return '';\n    }\n  }\n}\n```\n\n3. Update the UI styling to properly display ghost text:\n```css\n.ghost-suggestion {\n  color: rgba(128, 128, 128, 0.8);\n  font-family: inherit;\n  font-size: inherit;\n  white-space: pre;\n  pointer-events: none;\n  user-select: none;\n}\n\n/* Dark theme support */\n.dark-theme .ghost-suggestion {\n  color: rgba(180, 180, 180, 0.8);\n}\n```\n\n4. Add user preferences for auto-completion:\n```typescript\ninterface AutoCompletionPreferences {\n  enabled: boolean;\n  minCharactersBeforeSuggesting: number;\n  suggestionDelay: number;\n  maxSuggestionLength: number;\n}\n\n// Add to StateManager\nclass StateManager {\n  // ... existing code ...\n  \n  private autoCompletionPreferences: AutoCompletionPreferences = {\n    enabled: true,\n    minCharactersBeforeSuggesting: 3,\n    suggestionDelay: 300,\n    maxSuggestionLength: 100\n  };\n  \n  getAutoCompletionPreferences(): AutoCompletionPreferences {\n    return {...this.autoCompletionPreferences};\n  }\n  \n  updateAutoCompletionPreferences(prefs: Partial<AutoCompletionPreferences>): void {\n    this.autoCompletionPreferences = {...this.autoCompletionPreferences, ...prefs};\n    this.notifyListeners('autoCompletionPreferences', this.autoCompletionPreferences);\n  }\n}\n```\n\n5. Implement performance optimizations:\n   - Cache recent suggestions to reduce API calls\n   - Implement intelligent triggering based on typing patterns\n   - Limit suggestion frequency to maintain editor responsiveness\n\n6. Add visual indicators for suggestion status:\n   - Small loading indicator when waiting for suggestions\n   - Subtle animation when suggestion appears\n   - Visual feedback when suggestion is accepted\n\n7. Implement accessibility considerations:\n   - Ensure ghost text has sufficient contrast\n   - Add screen reader announcements for suggestions\n   - Provide keyboard shortcuts for managing suggestions",
        "testStrategy": "1. Unit Testing:\n   - Test the AutoCompletionService methods in isolation\n   - Mock the GemmaService to return predictable suggestions\n   - Verify suggestion display, acceptance, and dismissal logic\n   - Test keyboard event handling for Tab and Escape keys\n   - Verify debouncing behavior works correctly\n\n2. Integration Testing:\n   - Test integration between AutoCompletionService and Editor\n   - Verify suggestions appear correctly after typing\n   - Test suggestion acceptance updates the document correctly\n   - Verify suggestions are properly cleared when typing continues\n   - Test interaction with other editor features (e.g., formatting, block operations)\n\n3. Performance Testing:\n   - Measure latency between typing and suggestion appearance\n   - Test with large documents to ensure performance remains acceptable\n   - Verify memory usage doesn't increase significantly during extended editing sessions\n   - Test CPU usage during rapid typing with suggestions enabled\n\n4. User Experience Testing:\n   - Conduct A/B testing with different suggestion delay times\n   - Gather feedback on suggestion quality and relevance\n   - Test with different writing styles and document types\n   - Verify ghost text is visually distinguishable but not distracting\n   - Test with users who have different accessibility needs\n\n5. Cross-browser Testing:\n   - Verify ghost text rendering in different browsers\n   - Test keyboard handling consistency across platforms\n   - Verify performance is acceptable on lower-end devices\n\n6. Automated End-to-End Tests:\n   - Create Playwright tests that simulate typing and verify suggestions appear\n   - Test Tab key acceptance of suggestions\n   - Test Escape key dismissal of suggestions\n   - Verify suggestions are context-aware based on document content\n\n7. Edge Case Testing:\n   - Test behavior when switching between documents\n   - Verify suggestions work correctly at document boundaries\n   - Test with different languages and special characters\n   - Verify behavior when multiple users are editing simultaneously",
        "status": "done",
        "dependencies": [
          6,
          5,
          2,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Reference Document Upload Feature",
        "description": "Create a system that allows users to upload plain text and markdown files as reference materials that the AI can access when generating content, providing more informed and accurate responses.",
        "details": "1. Design the Reference Document Manager:\n```typescript\ninterface ReferenceDocument {\n  id: string;\n  name: string;\n  content: string;\n  format: 'plaintext' | 'markdown';\n  dateAdded: Date;\n  size: number; // in bytes\n}\n\nclass ReferenceManager {\n  private documents: ReferenceDocument[] = [];\n  private storage: FileStorageService;\n  private stateManager: StateManager;\n  \n  constructor(storage: FileStorageService, stateManager: StateManager) {\n    this.storage = storage;\n    this.stateManager = stateManager;\n  }\n  \n  async uploadDocument(file: File): Promise<ReferenceDocument> {\n    // Validate file type and size\n    if (!['text/plain', 'text/markdown'].includes(file.type)) {\n      throw new Error('Unsupported file format. Only plain text and markdown files are supported.');\n    }\n    \n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n      throw new Error('File size exceeds the 5MB limit.');\n    }\n    \n    // Read file content\n    const content = await this.readFileContent(file);\n    \n    // Create document object\n    const document: ReferenceDocument = {\n      id: generateUUID(),\n      name: file.name,\n      content,\n      format: file.type === 'text/markdown' ? 'markdown' : 'plaintext',\n      dateAdded: new Date(),\n      size: file.size\n    };\n    \n    // Save to storage\n    await this.storage.saveReferenceDocument(document);\n    \n    // Add to local collection\n    this.documents.push(document);\n    \n    // Update application state\n    this.stateManager.updateState({\n      references: {\n        documents: this.documents\n      }\n    });\n    \n    return document;\n  }\n  \n  async deleteDocument(id: string): Promise<void> {\n    const index = this.documents.findIndex(doc => doc.id === id);\n    if (index === -1) {\n      throw new Error('Document not found');\n    }\n    \n    // Remove from storage\n    await this.storage.deleteReferenceDocument(id);\n    \n    // Remove from local collection\n    this.documents.splice(index, 1);\n    \n    // Update application state\n    this.stateManager.updateState({\n      references: {\n        documents: this.documents\n      }\n    });\n  }\n  \n  getDocuments(): ReferenceDocument[] {\n    return [...this.documents];\n  }\n  \n  getDocumentById(id: string): ReferenceDocument | undefined {\n    return this.documents.find(doc => doc.id === id);\n  }\n  \n  private async readFileContent(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => reject(new Error('Failed to read file'));\n      reader.readAsText(file);\n    });\n  }\n  \n  async loadDocuments(): Promise<void> {\n    this.documents = await this.storage.loadReferenceDocuments();\n  }\n}\n```\n\n2. Extend the FileStorageService to handle reference documents:\n```typescript\nclass FileStorageService {\n  // Existing methods...\n  \n  async saveReferenceDocument(document: ReferenceDocument): Promise<void> {\n    // Implementation depends on storage mechanism (IndexedDB, localStorage, etc.)\n    const documents = await this.loadReferenceDocuments();\n    documents.push(document);\n    localStorage.setItem('referenceDocuments', JSON.stringify(documents));\n  }\n  \n  async loadReferenceDocuments(): Promise<ReferenceDocument[]> {\n    const documentsJson = localStorage.getItem('referenceDocuments');\n    if (!documentsJson) {\n      return [];\n    }\n    \n    const documents = JSON.parse(documentsJson) as ReferenceDocument[];\n    // Convert string dates back to Date objects\n    return documents.map(doc => ({\n      ...doc,\n      dateAdded: new Date(doc.dateAdded)\n    }));\n  }\n  \n  async deleteReferenceDocument(id: string): Promise<void> {\n    const documents = await this.loadReferenceDocuments();\n    const updatedDocuments = documents.filter(doc => doc.id !== id);\n    localStorage.setItem('referenceDocuments', JSON.stringify(updatedDocuments));\n  }\n}\n```\n\n3. Create the Reference Manager UI component:\n```typescript\nclass ReferenceManagerUI {\n  private referenceManager: ReferenceManager;\n  private container: HTMLElement;\n  \n  constructor(referenceManager: ReferenceManager, container: HTMLElement) {\n    this.referenceManager = referenceManager;\n    this.container = container;\n    this.initialize();\n  }\n  \n  private initialize(): void {\n    // Create UI structure\n    this.container.innerHTML = `\n      <div class=\"reference-manager\">\n        <h3>Reference Documents</h3>\n        <div class=\"upload-section\">\n          <input type=\"file\" id=\"reference-file-input\" accept=\".txt,.md,text/plain,text/markdown\" style=\"display: none;\">\n          <button id=\"upload-reference-btn\" class=\"primary-btn\">Upload Document</button>\n        </div>\n        <div class=\"documents-list\"></div>\n      </div>\n    `;\n    \n    // Attach event listeners\n    const uploadBtn = this.container.querySelector('#upload-reference-btn');\n    const fileInput = this.container.querySelector('#reference-file-input');\n    \n    uploadBtn?.addEventListener('click', () => {\n      fileInput?.click();\n    });\n    \n    fileInput?.addEventListener('change', async (event) => {\n      const input = event.target as HTMLInputElement;\n      if (input.files && input.files.length > 0) {\n        try {\n          await this.referenceManager.uploadDocument(input.files[0]);\n          this.renderDocumentsList();\n          input.value = ''; // Reset input\n        } catch (error) {\n          alert(error.message);\n        }\n      }\n    });\n    \n    // Initial render\n    this.renderDocumentsList();\n  }\n  \n  private renderDocumentsList(): void {\n    const listContainer = this.container.querySelector('.documents-list');\n    if (!listContainer) return;\n    \n    const documents = this.referenceManager.getDocuments();\n    \n    if (documents.length === 0) {\n      listContainer.innerHTML = '<p class=\"empty-state\">No reference documents uploaded yet.</p>';\n      return;\n    }\n    \n    listContainer.innerHTML = `\n      <ul class=\"documents-list-items\">\n        ${documents.map(doc => `\n          <li class=\"document-item\" data-id=\"${doc.id}\">\n            <div class=\"document-info\">\n              <span class=\"document-name\">${escapeHTML(doc.name)}</span>\n              <span class=\"document-meta\">\n                ${formatFileSize(doc.size)}  ${formatDate(doc.dateAdded)}\n              </span>\n            </div>\n            <button class=\"delete-btn\" data-id=\"${doc.id}\">Delete</button>\n          </li>\n        `).join('')}\n      </ul>\n    `;\n    \n    // Attach delete event listeners\n    const deleteButtons = listContainer.querySelectorAll('.delete-btn');\n    deleteButtons.forEach(btn => {\n      btn.addEventListener('click', async (event) => {\n        const id = (event.target as HTMLElement).getAttribute('data-id');\n        if (id) {\n          if (confirm('Are you sure you want to delete this reference document?')) {\n            await this.referenceManager.deleteDocument(id);\n            this.renderDocumentsList();\n          }\n        }\n      });\n    });\n  }\n  \n  // Helper functions\n  private escapeHTML(str: string): string {\n    return str\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;');\n  }\n  \n  private formatFileSize(bytes: number): string {\n    if (bytes < 1024) return bytes + ' B';\n    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';\n    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';\n  }\n  \n  private formatDate(date: Date): string {\n    return date.toLocaleDateString();\n  }\n}\n```\n\n4. Extend the GemmaService to incorporate reference documents:\n```typescript\nclass GemmaService {\n  // Existing properties and methods...\n  private referenceManager: ReferenceManager;\n  \n  constructor(/* existing parameters */, referenceManager: ReferenceManager) {\n    // Existing initialization...\n    this.referenceManager = referenceManager;\n  }\n  \n  // Modify existing methods to include reference documents\n  async generateCompletion(prompt: string, options?: CompletionOptions): Promise<string> {\n    // Get relevant reference documents\n    const referenceContext = await this.getRelevantReferenceContext(prompt);\n    \n    // Combine document context with reference context\n    const enhancedPrompt = this.createEnhancedPrompt(prompt, referenceContext);\n    \n    // Existing completion logic with enhanced prompt\n    return this.model.generateText(enhancedPrompt, options);\n  }\n  \n  private async getRelevantReferenceContext(prompt: string): Promise<string> {\n    const documents = this.referenceManager.getDocuments();\n    if (documents.length === 0) {\n      return '';\n    }\n    \n    // Simple approach: concatenate all reference documents\n    // In a more advanced implementation, you could use embeddings to find relevant documents\n    const allReferences = documents.map(doc => {\n      return `--- Reference: ${doc.name} ---\\n${doc.content}\\n`;\n    }).join('\\n');\n    \n    return allReferences;\n  }\n  \n  private createEnhancedPrompt(originalPrompt: string, referenceContext: string): string {\n    if (!referenceContext) {\n      return originalPrompt;\n    }\n    \n    return `I have the following reference materials that may be helpful:\n\n${referenceContext}\n\nBased on these references and your knowledge, please respond to:\n${originalPrompt}`;\n  }\n}\n```\n\n5. Update the AppLayout to include the reference manager in the sidebar:\n```typescript\nclass AppLayout {\n  // Existing properties...\n  private referenceManager: ReferenceManager;\n  private referenceManagerUI: ReferenceManagerUI;\n  \n  constructor(/* existing parameters */, referenceManager: ReferenceManager) {\n    // Existing initialization...\n    this.referenceManager = referenceManager;\n    \n    // Create sidebar tabs including reference manager\n    const sidebarContainer = document.querySelector('.sidebar-container');\n    if (sidebarContainer) {\n      this.createSidebarTabs(sidebarContainer);\n    }\n  }\n  \n  private createSidebarTabs(container: Element): void {\n    container.innerHTML = `\n      <div class=\"sidebar-tabs\">\n        <button class=\"tab-btn active\" data-tab=\"chat\">Chat</button>\n        <button class=\"tab-btn\" data-tab=\"composer\">Composer</button>\n        <button class=\"tab-btn\" data-tab=\"references\">References</button>\n        <button class=\"tab-btn\" data-tab=\"settings\">Settings</button>\n      </div>\n      <div class=\"tab-content\">\n        <div id=\"chat-tab\" class=\"tab-pane active\"></div>\n        <div id=\"composer-tab\" class=\"tab-pane\"></div>\n        <div id=\"references-tab\" class=\"tab-pane\"></div>\n        <div id=\"settings-tab\" class=\"tab-pane\"></div>\n      </div>\n    `;\n    \n    // Initialize reference manager UI\n    const referencesTab = container.querySelector('#references-tab');\n    if (referencesTab) {\n      this.referenceManagerUI = new ReferenceManagerUI(this.referenceManager, referencesTab as HTMLElement);\n    }\n    \n    // Attach tab switching logic\n    const tabButtons = container.querySelectorAll('.tab-btn');\n    tabButtons.forEach(btn => {\n      btn.addEventListener('click', () => {\n        // Remove active class from all buttons and panes\n        tabButtons.forEach(b => b.classList.remove('active'));\n        container.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));\n        \n        // Add active class to clicked button and corresponding pane\n        btn.classList.add('active');\n        const tabName = btn.getAttribute('data-tab');\n        container.querySelector(`#${tabName}-tab`)?.classList.add('active');\n        \n        // Update application state\n        this.stateManager.updateState({\n          ui: {\n            activeTab: tabName\n          }\n        });\n      });\n    });\n  }\n}\n```\n\n6. Update the application initialization to include the reference manager:\n```typescript\nclass WYSIWYGNoteApp {\n  // Existing properties...\n  private referenceManager: ReferenceManager;\n  \n  constructor() {\n    // Initialize core services\n    this.stateManager = new StateManager();\n    this.fileStorage = new FileStorageService();\n    \n    // Initialize reference manager\n    this.referenceManager = new ReferenceManager(this.fileStorage, this.stateManager);\n    \n    // Load reference documents\n    this.referenceManager.loadDocuments().then(() => {\n      console.log('Reference documents loaded');\n    });\n    \n    // Initialize Gemma service with reference manager\n    this.gemmaService = new GemmaService(/* existing parameters */, this.referenceManager);\n    \n    // Initialize other components\n    // ...\n    \n    // Initialize UI with reference manager\n    this.appLayout = new AppLayout(\n      /* existing parameters */,\n      this.referenceManager\n    );\n  }\n}\n```\n\n7. Add CSS styles for the reference manager:\n```css\n/* Reference Manager Styles */\n.reference-manager {\n  padding: 1rem;\n}\n\n.reference-manager h3 {\n  margin-top: 0;\n  margin-bottom: 1rem;\n}\n\n.upload-section {\n  margin-bottom: 1.5rem;\n}\n\n.primary-btn {\n  background-color: var(--primary-color);\n  color: white;\n  border: none;\n  padding: 0.5rem 1rem;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: 500;\n}\n\n.primary-btn:hover {\n  background-color: var(--primary-color-dark);\n}\n\n.documents-list {\n  margin-top: 1rem;\n}\n\n.empty-state {\n  color: var(--text-muted);\n  font-style: italic;\n}\n\n.documents-list-items {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.document-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.75rem;\n  border-bottom: 1px solid var(--border-color);\n}\n\n.document-info {\n  display: flex;\n  flex-direction: column;\n}\n\n.document-name {\n  font-weight: 500;\n  margin-bottom: 0.25rem;\n}\n\n.document-meta {\n  font-size: 0.8rem;\n  color: var(--text-muted);\n}\n\n.delete-btn {\n  background-color: transparent;\n  color: var(--danger-color);\n  border: 1px solid var(--danger-color);\n  padding: 0.25rem 0.5rem;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.delete-btn:hover {\n  background-color: var(--danger-color);\n  color: white;\n}\n```",
        "testStrategy": "1. Unit Testing:\n   - Test the ReferenceManager class methods in isolation\n   - Verify document upload, deletion, and retrieval functionality\n   - Test file validation logic for different file types and sizes\n   - Mock FileStorageService to test storage interactions\n   - Test error handling for invalid files and operations\n\n2. Integration Testing:\n   - Test integration between ReferenceManager and FileStorageService\n   - Verify that documents are properly saved and loaded from storage\n   - Test integration with GemmaService to ensure reference documents are included in prompts\n   - Verify that the UI correctly displays and manages reference documents\n   - Test that the sidebar tab navigation works correctly with the reference manager tab\n\n3. UI Testing:\n   - Test the reference manager UI rendering and interactions\n   - Verify that document list updates correctly after uploads and deletions\n   - Test responsive design and layout on different screen sizes\n   - Verify accessibility of the reference manager UI\n   - Test drag-and-drop file upload functionality if implemented\n\n4. Performance Testing:\n   - Test upload and processing of large text files (up to the 5MB limit)\n   - Measure impact on application performance when many reference documents are loaded\n   - Test AI generation performance with and without reference documents\n   - Verify that large reference contexts don't cause issues with the AI model\n\n5. User Acceptance Testing:\n   - Have users upload various reference documents and test the AI's ability to use them\n   - Gather feedback on the reference manager UI and workflow\n   - Test with real-world use cases like technical documentation, research papers, etc.\n   - Verify that the AI properly incorporates reference information in its responses\n\n6. Edge Case Testing:\n   - Test with empty reference documents\n   - Test with very large reference documents at the size limit\n   - Test with reference documents in different languages\n   - Test with malformed markdown files\n   - Verify behavior when reference documents contain code snippets or special formatting",
        "status": "pending",
        "dependencies": [
          2,
          3,
          5,
          7,
          8,
          10,
          11
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-04T14:19:24.204Z",
      "updated": "2025-08-05T00:39:17.965Z",
      "description": "Tasks for master context"
    }
  }
}